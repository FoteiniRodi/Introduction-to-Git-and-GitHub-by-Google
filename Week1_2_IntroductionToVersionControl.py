#%%
"""
Introduction to Git and GitHub, by Google

WEEK 1 â€“ Introduction to Version Control

1.2      Before Version Control
1.2.1	 Intro to Module 1: Version Control
1.2.2    Keeping Historical Copies
1.2.3    Diffing Files
1.2.4    Applying Changes
1.2.5    Practical Application of diff and patch
1.2.6    diff and patch Cheat Sheet 
1.2.7    Practice Quiz

MY SYNOPSIS
1
diff command: finds and displays differences between two files on our screen
e.g. diff rearrange1.py rearrange2.py
e.g. diff validations1.py validations2.py
e.g. diff -u validations1.py validations2.py, diff -u command provides more info than diff command

diff    displays symbol <, to indicate this line was removed (and symbol > to indicate this line was added)
diff -u displays minus sign -, to indicate lines that were removed (and + to indicate lines were added)

2
generate a diff file. Use the diff file to apply changes to the original problematic script with the patch command
A)   construct the diff file:
    diff -u old_file new_file > change.diff     (diff -u command finds differences between old_file and new_file
                                                 > re-direction operator, stores output of the diff -u command in the file change.diff
                                                 change.diff is the file where the differences are stored
                                                 It is called diff file or patch file)
    
B)  use the patch command to correct original file with the diff file    
    diff -u cpu_usage1.py cpu_usage2.py > cpu_usage.diff (generate diff file
    patch cpu_usage1.py  < cpu_usage.diff                 correct original file with the diff file
                                                          < re-direction operator, takes input from the diff file



Patch takes a file generated by diff and applies the changes to the original file
patch syntax: patch oldfile.py < oldfile.diff (old file receives INPUT from the diff file and gets corrected)
"""
#%%
"""
1.2.3    Diffing Files

with diff we can only SEE the differences between two files (or two directories!)

diff     compares two files, displays differences. works line by line
diff -u  compares two files, displays differences with more detail. works line by line
wdiff    compares two files, highlights the words that have changed in a file instead of working line by line like diff does
         does not work line by line

diff:
the symbol <, tells us that this line was removed 
the symbol >, tells us that this line was added 

diff splits the changes into separate sections
e.g. 5c5,6 is a section. Line 5 of first file was replaced by lines 5,6 in the second file. c means change
e.g  11a13,15 is a section. After Line 11 of first file three lines were added in the second file:13,14,15. a means addition (indicates that a line was added)

diff -u:
minus sign -, shows lines that were removed
plus sign +, shows lines that were added
   
Graphical Tools
Graphical tools, display files side by side and highlight the differences by using color
e.g. meld, KDiff3, vimdiff

EXAMPLE 1: compare rearrange1.py to rearrange2.py with diff
EXAMPLE 2: compare validations1.py to validations2.py with diff
EXAMPLE 3: compare validations1.py to validations2.py with diff -u
"""
"""
EXAMPLE 1: compare rearrange1.py to rearrange2.py with diff
rearrange1.py
"""
#!/usr/bin/env python 3 THIS IS THE SHEBANG LINE FOR PYTHON SCRIPTS IN THE LINUX OS
import re
def rearrange_name(name):
    result = re.search(r"^([\w .]*), ([\w .]*)$", name)
    if result == None:
        return result
    return "{} {}".format(result[2], result[1])

"""
rearrange2.py
"""
#!/usr/bin/env python 3 THIS IS THE SHEBANG LINE FOR PYTHON SCRIPTS IN THE LINUX OS
import re
def rearrange_name(name):
    result = re.search(r"^([\w .-]*), ([\w .-]*)$", name)
    if result == None:
        return result
    return "{} {}".format(result[2], result[1])


"""
LINUX COMMAND LINE
diff rearrange1.py rearrange2.py
Output is:
6c6
< result = re.search(r"^([\w .]*), ([\w .]*)$", name)   # the symbol <, tells us that this line was removed 
---
> result = re.search(r"^([\w .-]*), ([\w .-]*)$", name) # the symbol >, tells us that this line was added  
"""

"""
EXAMPLE 2: compare validations1.py to validations2.py with diff
validations1.py
"""
def validate_user(username, minlen):
    assert type(username) == str, "username must be a string"
    if minlen < 1:
        raise ValueError("minlen must be at least 1")
    if len(username) < minlen: # if length of username is smaller than defined minimum length, RETURN the value False
        return False
    if not username.isalnm(): # if the username does not contain alphanumeric characters, RETURN the value False
        return False
    return True # else RETURN the value True

"""
validations2.py
unfortunately, I do not have this py file
"""

"""
LINUX COMMAND LINE
diff validations1.py validations2.py
Output is:
5c5,6
< assert type(username) == str, "username must be a string"
---
> if type(username) != str:
>   raise TypeError("username must be a string")
11a13,15
>   return False
> # Usernames can't begin with a number
> if username[0].isnumeric():
    
EXPLANATION
diff splits the changes into two separate sections
section 5c5,6 and section 11a13,15
The section 5c5,6 shows one line in the first line that was 
replaced by two lines in the second file.
5 indicates the line in the first and in the second file
c indicates that a line was changed

The section 11a13,15 shows three lines that are new in the second file
a indicates that a line was added
this addition looks strange because the added if block has no body
we will solve this by using diff -u and not just diff
"""

"""
EXAMPLE 3: compare validations1.py to validations2.py with diff -u
"""
"""
LINUX COMMAND LINE
diff -u validations1.py validations2.py
Output is:
--- validations1.py 2020-01-05 07:03:46.999900910 -0000
+++ validations2.py 2020-01-05 07:03:46.999900910 -0000
@@ -2,7 +2,8 @@

def validate_user(username, minlen):
- assert type(username) == str, "username must be a string"
+ if type(username) != str:
+   raise TypeError("username must be a string")
  if minlen < 1:
      raise ValueError("minlen must be at least 1")
  
@@ -10,5 +11,8 @@
    return False
  if not username.isalnum():
      return False
+ # Usernames can't begin with a number
+ if username[0].isnumeric():
+    return False
  return True
    
EXPLANATION 
minus sign -, shows lines that were removed
plus sign +, shows lines that were added
"""
#%%
"""
1.2.4    Applying Changes

How to generate diff files and how to apply their contents with the patch command

In-Video question
What does the patch command do?
Answer= It applies the changes contained in a diff file to another file

we have the "old_file" with a bug and ask a colleague to fix it.
The colleague is correcting our code and creates a new file "new_file". He creates a diff file to help us more.
We receive the diff file and in order to apply the changes to our old_file, we use the patch command.
Patch takes a file generated by diff and applies the changes to the original file
patch syntax: patch oldfile.py < oldfile.diff (old file receives INPUT from the diff file and gets corrected)

It is necessary to use diff files to correct the code in the original files in order to avoid mistakes 
(remember we can diff whole directory structures and in that case the diff file can specify where each change file should be without us having to do any manual work)
It is necessary to use the patch command to apply the changes to the old file in order to avoid mistakes!

LINUX COMMAND LINE:
diff -u old_file new_file > change.diff      # construction of the diff file
                                             # compare old and new, store the result/output to the diff file

The sign >, re-directs the output of the diff command to the file "change.diff"
The file "change.diff" contains the differences between old and new file.
the generated file "change.diff", is usually refereed to as the DIFf FILE OR THE PATCH FILE
We are using diff -u and not just diff, to display more details of the differences

"""

"""
EXAMPLE
we have a small script that checks whether the computer is under too much load

LINUX COMMAND LINE:
cat cpu_usage.py                       # this is the old_file
OUTPUT IS:
#!/usr/bin/env python3
import psutil
def check_cpu_usage(percent):
    usage = psutil.cpu_percent()
    return usage < percent
if not check_cpu_usage(75):
    print("ERROR! CPU is overloaded")
else:
    print("Everything ok")
    
cat cpu_usage.diff                   # this is the diff file
OUTPUT IS:
--- cpu_usage.py 2019-06-23 00:16:04.66645429 -0700
+++ cpu_usage.py 2019-06-23 00:15:37.5343001 -0700
@@ -2,7 +2,8 @@
import psutil

def check_cpu_usage(percent):
-  usage = psutil.cpu_percent()
+  usage = psutil.cpu_percent(1)           # the colleague added 1 in the parenthesis
+  print("DEBUG: usage {}".format(usage)) # the colleague added a debugging line, that prints the value returned by the function
   return usage < percent
   
if not check_cpu_usage(75):

Our colleague explains that 
by calling the CPU percent function without a parameter, 
we were not averaging over a period of time, and so the call always returns zero. 

LINUX COMMAND LINE:
patch cpu_usage.py  < cpu_usage.diff # the old file receives input from the diff file
                                     # we are using the re-direction operator < for input!
OUTPUT IS:
patching file cpu_usage.py           # file was patched/ corrected
                                     # changes we successfully applied

LINUX COMMAND LINE:
cat cpu_usage.py           # see contents of corrected script
OUTPUT IS:
#!/usr/bin/env python3
import psutil
def check_cpu_usage(percent):
    usage = psutil.cpu_percent(1)
    print("DEBUG: usage {}".format(usage))
    return usage < percent
if not check_cpu_usage(75):
    print("ERROR! CPU is overloaded")
else:
    print("Everything ok")

we can remove the de-bugging line but not now

"""
#%%
"""
1.2.5    Practical Application of diff and patch

disk_usage.py
The goal of the script is to check how much disk space is currently used, 
and print an error if it's too little space for normal operation

The script disk_usage.py has a problem and we need to fix it.

we will make 2 copies of disk_usage.py,
disk_usage_original.py which weâ€™ll keep unmodified and use for comparison
disk_usage_fixed.py which weâ€™ll edit, to repair our script

LINUX COMMAND LINE:
cp disk_usage.py disk_usage_original.py # make a copy of disk_usage.py, name it disk_usage_original.py
cp disk_usage.py disk_usage_fixed.py    # make a copy of disk_usage.py, name it disk_usage_fixed.py 

Now open two command line windows
in one window open the script disk_usage_fixed.py
"""
#!/usr/bin/env python3
import psutil
def check_disk_usage(disk, min_absolute, min_percent):  
    "Returns True if there is enough free disk space, false otherwise"
    du = shutil.disk_usage(disk)
     # Calculate the percentage of free space"
    percent_free = 100 * du.free / du.total
     # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
         return False
    return True
# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2*2**30, 10):
    print("ERROR: Not enough disk space")
    return 1
print("Everything ok")
return 0

"""
in another window
LINUX COMMAND LINE:
./disk_usage_fixed.py                   # execute/run the script
OUTPUT IS:
File ".disk_usage_fixed.py", line 19
return 1
^
SyntaxError: 'return' outside function

So, we have found a RETURN STATEMENT OUTSIDE A FUNCTION
In Python we can only use Return Statements INSIDE  a function
This is the problem of the script "disk_usage.py"

How can we fix this problem?
1)We could turn the current code into a function and then call that function from the main part of our script. 
2)we could use sys.exit to make the return number of the exit code of our script, which is the code that causes a program to exit with the corresponding exit value    

We will continue with solution 2, use sys.exit
"""
#!/usr/bin/env python3
import psutil
import sys
def check_disk_usage(disk, min_absolute, min_percent):  
    "Returns True if there is enough free disk space, false otherwise"
    du = shutil.disk_usage(disk)
     # Calculate the percentage of free space"
    percent_free = 100 * du.free / du.total
     # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
         return False
    return True
# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2*2**30, 10):
    print("ERROR: Not enough disk space")
    sys.exit(1)
    
print("Everything ok")
sys.exit(0)

# we added
# import sys
# sys.exit(1) instead of return 1
# sys.exit(0) instead of return 0

"""
We have fixed the script, lets execute it 

LINUX COMMAND LINE:
./disk_usage_fixed.py                   # execute/run the script
OUTPUT IS:
ERROR: Not enough disk space

Now we get a different error message, which is not true because we do have free space.
If we re-examine our code, gigabytes are calculated twice!! (we convert bytes to gigabytes 2 times)
1st time
if not check_disk_usage("/", 2*2**30, 10):
2**30 means 2 raised to the power of 30, number of bytes within a gigabyte

2nd time
gigabytes_free = du.free / 2**30

We will make changes to the script
"""
#!/usr/bin/env python3
import psutil
import sys
def check_disk_usage(disk, min_absolute, min_percent):  
    "Returns True if there is enough free disk space, false otherwise"
    du = shutil.disk_usage(disk)
     # Calculate the percentage of free space"
    percent_free = 100 * du.free / du.total
     # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
         return False
    return True
# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2, 10):
    print("ERROR: Not enough disk space")
    sys.exit(1)
    
print("Everything ok")
sys.exit(0)

# we corrected if not check_disk_usage("/", 2*2**30, 10): to
# if not check_disk_usage("/", 2, 10):

"""
We have re-fixed the script, lets execute it 

LINUX COMMAND LINE:
./disk_usage_fixed.py                   # execute/run the script
OUTPUT IS:
Everything is ok

Now we have corrected the script
we have to create the diff file and send it to our colleague

LINUX COMMAND LINE:
diff -u disk_usage_original.py disk_usage_fixed.py > disk_usage.diff with the diff -u command
Output is:
No output is shown
Explanation: we compare disk_usage_original.py and disk_usage_fixed.py
             their differences are saved in the diff file disk_usage.diff
             The colleague will use this diff file to correct his code

cat disk_usage.diff  # lets see the contents of the diff file
Output is:
+++ disk_usage_fixed.py  2020-01-05 14:04:32.748566252 -0000
@@ -1,6 +1,7 @@

#!/usr/bin/env python3
  import psutil
+ import sys
def check_disk_usage(disk, min_absolute, min_percent):  
    "Returns True if there is enough free disk space, false otherwise"
@@ -14,9 +15,9 @@
    return True

# Check for at least 2 GB and 10% free
-if not check_disk_usage("/", 2*2**30, 10):
+if not check_disk_usage("/", 2, 10):
    print("ERROR: Not enough disk space")
-   return 1
+   sys.exit(1)
    
print("Everything ok")
-return 0
+ sys.exit(0)

Now, the colleague will use the diff file to correct his/her file
LINUX COMMAND LINE:
patch disk_usage.py < disk_usage.diff # correct disk_usage.py with input from disk_usage.diff
Output is:
    No output here
./disk_usage.py # run the corrected file 
Output is:
Everything is ok

"""
"""
1.2.6    diff and patch Cheat Sheet 

diff
diff is used to find differences between two files. 
On its own, itâ€™s a bit hard to use; instead, use it with diff -u to find lines which differ in two files:

diff -u
diff -u is used to compare two files, line by line, and have the differing lines compared side-by-side 
in the same output. 

EXAMPLE (menu1 changes to menu2, use diff -u to display the differences)
menu1.txt   menu2.txt 
Menu1:      Menu:

Apples      Apples
Bananas     Bananas
Oranges     Grapes
Pears       Strawberries

diff -u menu1.txt menu2.txt 
--- menu1.txt   2019-12-16 18:46:13.794879924 +0900
+++ menu2.txt   2019-12-16 18:46:42.090995670 +0900
@@ -1,6 +1,6 @@
-Menu1:
+Menu:
 
 Apples
 Bananas
-Oranges
-Pears
+Grapes
+Strawberries


Patch
Patch is useful for applying file differences. 
See the below example, which compares two files. 
The comparison is saved as a .diff file, which is then patched to the original file!

hello_world.txt        hello_world_long.txt 
Hello World            Hello World
                       It's a wonderful day!

1st step, find differences
diff -u hello_world.txt hello_world_long.txt 
--- hello_world.txt     2019-12-16 19:24:12.556102821 +0900
+++ hello_world_long.txt        2019-12-16 19:24:38.944207773 +0900
@@ -1 +1,3 @@
 Hello World
+
+It's a wonderful day!

2nd step find differences AND create the diff file which contains the differences

diff -u hello_world.txt hello_world_long.txt > hello_world.diff
Output: nothing shown but the diff file is created

patch < hello_world.diff      # no file to ve corrected here ???
Output is:
patching file hello_world.txt

cat hello_world.txt          # display contents of corrected script
Hello World

It's a wonderful day!


here are some other interesting patch and diff commands such as patch -p1, diff -r !

Check them out in the following references:

http://man7.org/linux/man-pages/man1/diff.1.html
http://man7.org/linux/man-pages/man1/patch.1.html




"""




"""
1.2.7    Practice Quiz

Question 1
Your colleague sent you a patch called fix_names.patch, 
which fixes a config file called fix_names.conf. 
What command do you need to run to apply the patch to the config file?
(fix_names.diff, fixes a config file called fix_names.conf)

diff names.conf fix_names.conf
patch fix_names.conf names.conf
patch fix_names.conf < fix_names.patch CORRECT I am fixing fix_names.conf by using fix_names.diff as INPUT <
diff names.conf_orig names.conf_fixed > fix_names.conf

Notes: < is used to get input from a file
       > is used to send output to a file

Question 2
You're helping a friend with a bug in a script called fix_permissions.py, 
which fixes the permissions of a bunch of files. 
To work on the file, you make a copy and call it fix_permissions_modified.py. 
What command do you need to run after solving the bug to send the patch to your friend?
(after solving the problem I must create the diff file or patch file. 
I compare original and fixed and send the output to the diff file)

diff fix_permissions.py fix_permissions_modified.py > fix_permissions.patch CORRECT
patch fix_permissions.py < fix_permissions_modified.py
patch fix_permissions.py > fix_permissions.patch
diff fix_permissions.py fix_permissions.diff


Question 3
The _____ command highlights the words that changed in a file instead of working line by line.

1 point

diff
diff -u
wdiff CORRECT
patch


Question 4
How can we choose the return value our script returns when it finishes?

Using the exit command from the sys module CORRECT
Use the patch command
Use the diff command
Use meld

Question 5
In addition to the original files, what else do we need before we can use the patch command?


Diff file CORRECT
exit command of the sys module
Version control
Full copy of the new files


"""
