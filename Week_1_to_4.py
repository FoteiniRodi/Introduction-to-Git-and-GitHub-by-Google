#%%
"""
Introduction to Git and GitHub, by Google

WEEK 1 – Introduction to Version Control

1.2      Before Version Control
1.2.1	 Intro to Module 1: Version Control
1.2.2    Keeping Historical Copies
1.2.3    Diffing Files
1.2.4    Applying Changes
1.2.5    Practical Application of diff and patch
1.2.6    diff and patch Cheat Sheet 
1.2.7    Practice Quiz

MY SYNOPSIS
1
diff command: finds and displays differences between two files on our screen
e.g. diff rearrange1.py rearrange2.py
e.g. diff validations1.py validations2.py
e.g. diff -u validations1.py validations2.py, diff -u command provides more info than diff command

diff    displays symbol <, to indicate this line was removed (and symbol > to indicate this line was added)
diff -u displays minus sign -, to indicate lines that were removed (and + to indicate lines were added)

2
generate a diff file. Use the diff file to apply changes to the original problematic script with the patch command
A)   construct the diff file:
    diff -u old_file new_file > change.diff     (diff -u command finds differences between old_file and new_file
                                                 > re-direction operator, stores output of the diff -u command in the file change.diff
                                                 change.diff is the file where the differences are stored
                                                 It is called diff file or patch file)
    
B)  use the patch command to correct original file with the diff file    
    diff -u cpu_usage1.py cpu_usage2.py > cpu_usage.diff (generate diff file
    patch cpu_usage1.py  < cpu_usage.diff                 correct original file with the diff file
                                                          < re-direction operator, takes input from the diff file



Patch takes a file generated by diff and applies the changes to the original file
patch syntax: patch oldfile.py < oldfile.diff (old file receives INPUT from the diff file and gets corrected)
"""
#%%
"""
1.2.3    Diffing Files

with diff we can only SEE the differences between two files (or two directories!)

diff     compares two files, displays differences. works line by line
diff -u  compares two files, displays differences with more detail. works line by line
wdiff    compares two files, highlights the words that have changed in a file instead of working line by line like diff does
         does not work line by line

diff:
the symbol <, tells us that this line was removed 
the symbol >, tells us that this line was added 

diff splits the changes into separate sections
e.g. 5c5,6 is a section. Line 5 of first file was replaced by lines 5,6 in the second file. c means change
e.g  11a13,15 is a section. After Line 11 of first file three lines were added in the second file:13,14,15. a means addition (indicates that a line was added)

diff -u:
minus sign -, shows lines that were removed
plus sign +, shows lines that were added
   
Graphical Tools
Graphical tools, display files side by side and highlight the differences by using color
e.g. meld, KDiff3, vimdiff

EXAMPLE 1: compare rearrange1.py to rearrange2.py with diff
EXAMPLE 2: compare validations1.py to validations2.py with diff
EXAMPLE 3: compare validations1.py to validations2.py with diff -u
"""
"""
EXAMPLE 1: compare rearrange1.py to rearrange2.py with diff
rearrange1.py
"""
#!/usr/bin/env python 3 THIS IS THE SHEBANG LINE FOR PYTHON SCRIPTS IN THE LINUX OS
import re
def rearrange_name(name):
    result = re.search(r"^([\w .]*), ([\w .]*)$", name)
    if result == None:
        return result
    return "{} {}".format(result[2], result[1])

"""
rearrange2.py
"""
#!/usr/bin/env python 3 THIS IS THE SHEBANG LINE FOR PYTHON SCRIPTS IN THE LINUX OS
import re
def rearrange_name(name):
    result = re.search(r"^([\w .-]*), ([\w .-]*)$", name)
    if result == None:
        return result
    return "{} {}".format(result[2], result[1])


"""
LINUX COMMAND LINE
diff rearrange1.py rearrange2.py
Output is:
6c6
< result = re.search(r"^([\w .]*), ([\w .]*)$", name)   # the symbol <, tells us that this line was removed 
---
> result = re.search(r"^([\w .-]*), ([\w .-]*)$", name) # the symbol >, tells us that this line was added  
"""

"""
EXAMPLE 2: compare validations1.py to validations2.py with diff
validations1.py
"""
def validate_user(username, minlen):
    assert type(username) == str, "username must be a string"
    if minlen < 1:
        raise ValueError("minlen must be at least 1")
    if len(username) < minlen: # if length of username is smaller than defined minimum length, RETURN the value False
        return False
    if not username.isalnm(): # if the username does not contain alphanumeric characters, RETURN the value False
        return False
    return True # else RETURN the value True

"""
validations2.py
unfortunately, I do not have this py file
"""

"""
LINUX COMMAND LINE
diff validations1.py validations2.py
Output is:
5c5,6
< assert type(username) == str, "username must be a string"
---
> if type(username) != str:
>   raise TypeError("username must be a string")
11a13,15
>   return False
> # Usernames can't begin with a number
> if username[0].isnumeric():
    
EXPLANATION
diff splits the changes into two separate sections
section 5c5,6 and section 11a13,15
The section 5c5,6 shows one line in the first line that was 
replaced by two lines in the second file.
5 indicates the line in the first and in the second file
c indicates that a line was changed

The section 11a13,15 shows three lines that are new in the second file
a indicates that a line was added
this addition looks strange because the added if block has no body
we will solve this by using diff -u and not just diff
"""

"""
EXAMPLE 3: compare validations1.py to validations2.py with diff -u
"""
"""
LINUX COMMAND LINE
diff -u validations1.py validations2.py
Output is:
--- validations1.py 2020-01-05 07:03:46.999900910 -0000
+++ validations2.py 2020-01-05 07:03:46.999900910 -0000
@@ -2,7 +2,8 @@

def validate_user(username, minlen):
- assert type(username) == str, "username must be a string"
+ if type(username) != str:
+   raise TypeError("username must be a string")
  if minlen < 1:
      raise ValueError("minlen must be at least 1")
  
@@ -10,5 +11,8 @@
    return False
  if not username.isalnum():
      return False
+ # Usernames can't begin with a number
+ if username[0].isnumeric():
+    return False
  return True
    
EXPLANATION 
minus sign -, shows lines that were removed
plus sign +, shows lines that were added
"""
#%%
"""
1.2.4    Applying Changes

How to generate diff files and how to apply their contents with the patch command

In-Video question
What does the patch command do?
Answer= It applies the changes contained in a diff file to another file

we have the "old_file" with a bug and ask a colleague to fix it.
The colleague is correcting our code and creates a new file "new_file". He creates a diff file to help us more.
We receive the diff file and in order to apply the changes to our old_file, we use the patch command.
Patch takes a file generated by diff and applies the changes to the original file
patch syntax: patch oldfile.py < oldfile.diff (old file receives INPUT from the diff file and gets corrected)

It is necessary to use diff files to correct the code in the original files in order to avoid mistakes 
(remember we can diff whole directory structures and in that case the diff file can specify where each change file should be without us having to do any manual work)
It is necessary to use the patch command to apply the changes to the old file in order to avoid mistakes!

LINUX COMMAND LINE:
diff -u old_file new_file > change.diff      # construction of the diff file
                                             # compare old and new, store the result/output to the diff file

The sign >, re-directs the output of the diff command to the file "change.diff"
The file "change.diff" contains the differences between old and new file.
the generated file "change.diff", is usually refereed to as the DIFf FILE OR THE PATCH FILE
We are using diff -u and not just diff, to display more details of the differences

"""

"""
EXAMPLE
we have a small script that checks whether the computer is under too much load

LINUX COMMAND LINE:
cat cpu_usage.py                       # this is the old_file
OUTPUT IS:
#!/usr/bin/env python3
import psutil
def check_cpu_usage(percent):
    usage = psutil.cpu_percent()
    return usage < percent
if not check_cpu_usage(75):
    print("ERROR! CPU is overloaded")
else:
    print("Everything ok")
    
cat cpu_usage.diff                   # this is the diff file
OUTPUT IS:
--- cpu_usage.py 2019-06-23 00:16:04.66645429 -0700
+++ cpu_usage.py 2019-06-23 00:15:37.5343001 -0700
@@ -2,7 +2,8 @@
import psutil

def check_cpu_usage(percent):
-  usage = psutil.cpu_percent()
+  usage = psutil.cpu_percent(1)           # the colleague added 1 in the parenthesis
+  print("DEBUG: usage {}".format(usage)) # the colleague added a debugging line, that prints the value returned by the function
   return usage < percent
   
if not check_cpu_usage(75):

Our colleague explains that 
by calling the CPU percent function without a parameter, 
we were not averaging over a period of time, and so the call always returns zero. 

LINUX COMMAND LINE:
patch cpu_usage.py  < cpu_usage.diff # the old file receives input from the diff file
                                     # we are using the re-direction operator < for input!
OUTPUT IS:
patching file cpu_usage.py           # file was patched/ corrected
                                     # changes we successfully applied

LINUX COMMAND LINE:
cat cpu_usage.py           # see contents of corrected script
OUTPUT IS:
#!/usr/bin/env python3
import psutil
def check_cpu_usage(percent):
    usage = psutil.cpu_percent(1)
    print("DEBUG: usage {}".format(usage))
    return usage < percent
if not check_cpu_usage(75):
    print("ERROR! CPU is overloaded")
else:
    print("Everything ok")

we can remove the de-bugging line but not now

"""
#%%
"""
1.2.5    Practical Application of diff and patch

disk_usage.py
The goal of the script is to check how much disk space is currently used, 
and print an error if it's too little space for normal operation

The script disk_usage.py has a problem and we need to fix it.

we will make 2 copies of disk_usage.py,
disk_usage_original.py which we’ll keep unmodified and use for comparison
disk_usage_fixed.py which we’ll edit, to repair our script

LINUX COMMAND LINE:
cp disk_usage.py disk_usage_original.py # make a copy of disk_usage.py, name it disk_usage_original.py
cp disk_usage.py disk_usage_fixed.py    # make a copy of disk_usage.py, name it disk_usage_fixed.py 

Now open two command line windows
in one window open the script disk_usage_fixed.py
"""
#!/usr/bin/env python3
import psutil
def check_disk_usage(disk, min_absolute, min_percent):  
    "Returns True if there is enough free disk space, false otherwise"
    du = shutil.disk_usage(disk)
     # Calculate the percentage of free space"
    percent_free = 100 * du.free / du.total
     # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
         return False
    return True
# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2*2**30, 10):
    print("ERROR: Not enough disk space")
    return 1
print("Everything ok")
return 0

"""
in another window
LINUX COMMAND LINE:
./disk_usage_fixed.py                   # execute/run the script
OUTPUT IS:
File ".disk_usage_fixed.py", line 19
return 1
^
SyntaxError: 'return' outside function

So, we have found a RETURN STATEMENT OUTSIDE A FUNCTION
In Python we can only use Return Statements INSIDE  a function
This is the problem of the script "disk_usage.py"

How can we fix this problem?
1)We could turn the current code into a function and then call that function from the main part of our script. 
2)we could use sys.exit to make the return number of the exit code of our script, which is the code that causes a program to exit with the corresponding exit value    

We will continue with solution 2, use sys.exit
"""
#!/usr/bin/env python3
import psutil
import sys
def check_disk_usage(disk, min_absolute, min_percent):  
    "Returns True if there is enough free disk space, false otherwise"
    du = shutil.disk_usage(disk)
     # Calculate the percentage of free space"
    percent_free = 100 * du.free / du.total
     # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
         return False
    return True
# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2*2**30, 10):
    print("ERROR: Not enough disk space")
    sys.exit(1)
    
print("Everything ok")
sys.exit(0)

# we added
# import sys
# sys.exit(1) instead of return 1
# sys.exit(0) instead of return 0

"""
We have fixed the script, lets execute it 

LINUX COMMAND LINE:
./disk_usage_fixed.py                   # execute/run the script
OUTPUT IS:
ERROR: Not enough disk space

Now we get a different error message, which is not true because we do have free space.
If we re-examine our code, gigabytes are calculated twice!! (we convert bytes to gigabytes 2 times)
1st time
if not check_disk_usage("/", 2*2**30, 10):
2**30 means 2 raised to the power of 30, number of bytes within a gigabyte

2nd time
gigabytes_free = du.free / 2**30

We will make changes to the script
"""
#!/usr/bin/env python3
import psutil
import sys
def check_disk_usage(disk, min_absolute, min_percent):  
    "Returns True if there is enough free disk space, false otherwise"
    du = shutil.disk_usage(disk)
     # Calculate the percentage of free space"
    percent_free = 100 * du.free / du.total
     # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
         return False
    return True
# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2, 10):
    print("ERROR: Not enough disk space")
    sys.exit(1)
    
print("Everything ok")
sys.exit(0)

# we corrected if not check_disk_usage("/", 2*2**30, 10): to
# if not check_disk_usage("/", 2, 10):

"""
We have re-fixed the script, lets execute it 

LINUX COMMAND LINE:
./disk_usage_fixed.py                   # execute/run the script
OUTPUT IS:
Everything is ok

Now we have corrected the script
we have to create the diff file and send it to our colleague

LINUX COMMAND LINE:
diff -u disk_usage_original.py disk_usage_fixed.py > disk_usage.diff with the diff -u command
Output is:
No output is shown
Explanation: we compare disk_usage_original.py and disk_usage_fixed.py
             their differences are saved in the diff file disk_usage.diff
             The colleague will use this diff file to correct his code

cat disk_usage.diff  # lets see the contents of the diff file
Output is:
+++ disk_usage_fixed.py  2020-01-05 14:04:32.748566252 -0000
@@ -1,6 +1,7 @@

#!/usr/bin/env python3
  import psutil
+ import sys
def check_disk_usage(disk, min_absolute, min_percent):  
    "Returns True if there is enough free disk space, false otherwise"
@@ -14,9 +15,9 @@
    return True

# Check for at least 2 GB and 10% free
-if not check_disk_usage("/", 2*2**30, 10):
+if not check_disk_usage("/", 2, 10):
    print("ERROR: Not enough disk space")
-   return 1
+   sys.exit(1)
    
print("Everything ok")
-return 0
+ sys.exit(0)

Now, the colleague will use the diff file to correct his/her file
LINUX COMMAND LINE:
patch disk_usage.py < disk_usage.diff # correct disk_usage.py with input from disk_usage.diff
Output is:
    No output here
./disk_usage.py # run the corrected file 
Output is:
Everything is ok

"""
"""
1.2.6    diff and patch Cheat Sheet 

diff
diff is used to find differences between two files. 
On its own, it’s a bit hard to use; instead, use it with diff -u to find lines which differ in two files:

diff -u
diff -u is used to compare two files, line by line, and have the differing lines compared side-by-side 
in the same output. 

EXAMPLE (menu1 changes to menu2, use diff -u to display the differences)
menu1.txt   menu2.txt 
Menu1:      Menu:

Apples      Apples
Bananas     Bananas
Oranges     Grapes
Pears       Strawberries

diff -u menu1.txt menu2.txt 
--- menu1.txt   2019-12-16 18:46:13.794879924 +0900
+++ menu2.txt   2019-12-16 18:46:42.090995670 +0900
@@ -1,6 +1,6 @@
-Menu1:
+Menu:
 
 Apples
 Bananas
-Oranges
-Pears
+Grapes
+Strawberries


Patch
Patch is useful for applying file differences. 
See the below example, which compares two files. 
The comparison is saved as a .diff file, which is then patched to the original file!

hello_world.txt        hello_world_long.txt 
Hello World            Hello World
                       It's a wonderful day!

1st step, find differences
diff -u hello_world.txt hello_world_long.txt 
--- hello_world.txt     2019-12-16 19:24:12.556102821 +0900
+++ hello_world_long.txt        2019-12-16 19:24:38.944207773 +0900
@@ -1 +1,3 @@
 Hello World
+
+It's a wonderful day!

2nd step find differences AND create the diff file which contains the differences

diff -u hello_world.txt hello_world_long.txt > hello_world.diff
Output: nothing shown but the diff file is created

patch < hello_world.diff      # no file to ve corrected here ???
Output is:
patching file hello_world.txt

cat hello_world.txt          # display contents of corrected script
Hello World

It's a wonderful day!


here are some other interesting patch and diff commands such as patch -p1, diff -r !

Check them out in the following references:

http://man7.org/linux/man-pages/man1/diff.1.html
http://man7.org/linux/man-pages/man1/patch.1.html




"""




"""
1.2.7    Practice Quiz

Question 1
Your colleague sent you a patch called fix_names.patch, 
which fixes a config file called fix_names.conf. 
What command do you need to run to apply the patch to the config file?
(fix_names.diff, fixes a config file called fix_names.conf)

diff names.conf fix_names.conf
patch fix_names.conf names.conf
patch fix_names.conf < fix_names.patch CORRECT I am fixing fix_names.conf by using fix_names.diff as INPUT <
diff names.conf_orig names.conf_fixed > fix_names.conf

Notes: < is used to get input from a file
       > is used to send output to a file

Question 2
You're helping a friend with a bug in a script called fix_permissions.py, 
which fixes the permissions of a bunch of files. 
To work on the file, you make a copy and call it fix_permissions_modified.py. 
What command do you need to run after solving the bug to send the patch to your friend?
(after solving the problem I must create the diff file or patch file. 
I compare original and fixed and send the output to the diff file)

diff fix_permissions.py fix_permissions_modified.py > fix_permissions.patch CORRECT
patch fix_permissions.py < fix_permissions_modified.py
patch fix_permissions.py > fix_permissions.patch
diff fix_permissions.py fix_permissions.diff


Question 3
The _____ command highlights the words that changed in a file instead of working line by line.

1 point

diff
diff -u
wdiff CORRECT
patch


Question 4
How can we choose the return value our script returns when it finishes?

Using the exit command from the sys module CORRECT
Use the patch command
Use the diff command
Use meld

Question 5
In addition to the original files, what else do we need before we can use the patch command?


Diff file CORRECT
exit command of the sys module
Version control
Full copy of the new files


"""
# -*- coding: utf-8 -*-
"""
Created on Fri Nov 13 16:02:00 2020

@author: jimko
"""

#%%
"""
Introduction to Git and GitHub, by Google

WEEK 1 – Introduction to Version Control

1.3 Version Control Systems
1.3.1	What is version control?
1.3.2	Version Control and Automation
1.3.3	What is Git?
1.3.4	Reading: More Information About Git
1.3.5	Installing Git
1.3.6	Installing Git on Windows (Optional)
1.3.7	Reading: Installing Git
1.3.8	Practice Quiz

MY SYNOPSIS
a VCS records the changes we make to our files
A VCS is essentialy a system that stores files, but unlike a server it stores all the different versions of a file that we create as we save the file
There are many VCS's (Subversion, Mercurial) but we will use Git

Commit: a collection of edits/changes which we treat a a single edit/change
Commit Message: why the commit was performed
Repository: stores the files for which changes are recorded/tracked
In any organization that produces software, a VCS is a key part of managing the code
a VCS is not only used for files that contain code, but for any file that we need to monitor (e.g. text files, cofiguration files, data files etc.)
a VCS is not a good option for files with images and videos 
a VCS is useful for:
    -recoding history of changes
    -reverting back to previous versions of files that work, when a problem occurs 
    -for saving time and for automation of tasks
    -collaboration between many people
    -tracking changes we have made, even if I am the only person using it (after weeks I do not remember all details afterall)
    - it is not a back up system, so back up your files somewhere else
The Git VCS:
    -free open source system available for installation on Unix based platforms, Windows and macOS
    -not centralized around a single server
    -every person contributing to a repository has full copy of the repository on their own development machines
How to install Git
    - first check if it is already on our machine with git --version
    - for Windows OS, download Git from gitforwindows.org. PLEASE CHOOSE ATOM AS THE EDITOR
    - I did the download, now I am using Git Bash application (MINGW64) which allows me to practice Linux command on my Windows OS machine :)
"""
#%%
"""
1.3.1	What is version control?

Version Control System (VCS)
a VCS records the changes we make to our files

A VCS:
records -the type of changes we make to our files
         -when the changes were made
         -who made the changes
allows us to revert/undo a change 
facilitates collaboration by allowing to merge changes from lots of different sources

A VCS is essentialy a system that stores files
The difference with a file server (which saves the latest version of a file),
is that the VCS stores all the different versions of a file that we create as we save the file.

There are many VCS's, which work in a similar way, they store all versions of a file, they store type of change, when it was made and by who.

COMMIT 
we make edits to multiple files
then we treat the collection of edits as a SINGLE change, this is commit

A commit must always be accompanied by an explanation! COMMIT MESSAGE
(explanation= why the commit/single change was applied
what was fixed by this change. This helps us understand the history)

In any organization that produces software, a VCS is a key part of managing the code.

REPOSITORY
files are usually organized in Repositories.
A repository can be used by one or more people.

A VCS can be used also for files that do not contain only code, files that need to be monitored for changes.
e.g. a VCS can be used to store configuration files, documentation, data files, text files, or any other content that we may need to track/monitor for changes
VCS is not very useful for images or videos

So by using a VCS and diff command and patch command, we can find differences then make corrections etc.
"""
#%%
"""
1.3.2	Version Control and Automation


can a VCS help, even if you don't need to share your scripts or collaborate on them with others?
yes

example 1
a DNS zone file is a configuration file that specifies the mappings between IP addresses and host names in your network
when we update a DNS zone file we must use good explanatory commit messages
when a problem happens we can "roll back" to the previous version of a file which worked correctly and gain valuable time to fix the problematic files

example 2
DHCP daemon
DHCP:  Dynamic Host Configuration Protocol
daemon: a daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user.

Dynamic Host Configuration Protocol (DHCP) is a network management protocol 
used to automate the process of configuring devices on IP networks, 
thus allowing them to use network services such as DNS, NTP, and any communication protocol based on UDP or TCP.     

The configuration for a DHCP daemon can be replicated in two or more machines, 
where one acts as a primary server and the other one acts as standby machine.
The standby machines won't do much while the primary is up. 
BUT if the primary goes down for any reason, a standby machine can become primary and start responding to DHCP queries. 
For this to work, the configuration files on all machines need to be identical. 
This is because the DHCP protocol doesn't provide a way for standby machines to get an up-to-date version of the configuration files in the way DNS does. 
To deal with this, we can keep the up-to-date version of the DHCP configuration in a version control system 
and have the machines download the configuration from the VCS. 
This means all the machines will have the exact same files.

example 3
Say you get an urgent alert over the weekend, telling you that your DHCP server isn't responding to any queries. 
You look at the history of the changes and you find that one of the changes added on Friday evening, 
 included a duplicated entry causing the server to misbehave. 
By using a VCS, you can easily roll back the change and have the servers back to health in no time. 

You might come across a second unexpected benefit, when it's time to replace the server with a new one.
By having all the server configuration and a version control system, 
it's much easier to automate the task of deploying a new server.


In_Video question
Why is a version control system useful, even if it's used only by a single person? Check all that apply.

1 Seeing the history of the changes helps us understand what changed and why. CORRECT
One of the main benefits of a VCS is that you can see the history of how files changed and understand what changed at each step and what motivated the change.

2 Tracking code in a VCS ensures that it's bug free. not correct
a version control system doesn't ensure the quality of our code.

3 Tracking changes allows for easy rollbacks when a problem is detected. CORRECT
By having each change tracked in the VCS, it's very easy to go back to previous versions when an issue with a change is discovered.

4 Storing files in a VCS avoids the need for any kind of backups. not correct
While you can rely on the version control to keep track of your changes, you still need to ensure that you have proper backups of the data stored in the VCS itself.

In this course we will use Git,
which is one of the most popular version control systems in use today 
"""
#%%
"""
1.3.3	What is Git?

Git:
    free open source system available for installation on Unix based platforms, Windows and macOS
    it is not centralized around a single server
    it has a de-centralized architecture (This means that every person contributing to a repository has full copy of the repository on their own development machines.)
    Collaborators can "share" and "pull" in changes that others have made
    the repositories are all local to the computer being used to create the files, most operations can be done really fast
    Git can work as a standalone program as a server and as a client
    I can use Git on a single machine without a nrtwork connection
    I can use Git as a server on a machine where I want to host my repository
    I can use Git as a client TO access the repository from another machine
    You can use it for small projects with like one developer or huge projects with thousands of contributors. 
    You can use it to track private work that you can keep to yourself 
    You can use it to share your work with others by hosting a code on public servers like Github, Gitlab or others

In-Video question
What characteristics make Git particularly powerful? Check all that apply.

-It is a distributed VCS which means that each developer has a full cope of the repository. CORRECT
Because each contributor to a Git repo has a full copy of the repository, they can interact with the tracked files without needing a coordinating server. 
In turn, this improves collaboration.

- Repositories can be used by as many developers is needed
Because of the way Git was designed, repositories can be useful for any number of developers, from one to thousands.

the official Git website is called git-scm.com
scm= source control management
we prefer the term VCS version control system, because this includes files that contain e.g. text and not only code


Other VCS programs = Subversion, Mercurial
"""
#%%
"""
1.3.4	Reading: More Information About Git

Check out the following links for more information:

https://git-scm.com/doc
https://www.mercurial-scm.org/
https://subversion.apache.org/
https://en.wikipedia.org/wiki/Version_control
"""
#%%
"""
1.3.5	Installing Git

Check whether we have git already installed:
git --version


On Windows, after downloading and executing the installer,Pay attention to the editor question though. 
You'll probably want to change the editor to one that you feel comfortable with, like Notepad++ or Atom.

ATTENTION
One interesting thing about the Windows installation is that it comes preloaded with an environment called MinGW64. 
This environment lets us operate on Windows with the same commands and tools available on Linux.
So you can practice some Linux command line tools on your Windows machine. 
"""
#%%
"""
1.3.6	Installing Git on Windows (Optional)

visit gitforwindows.org
choose Atom as the editor
"""
#%%
"""
1.3.7	Reading: Installing Git

The first step on the way to using Git is to install it! The directions found in the Git documentation below are pretty thorough and helpful, check them out for the best method of getting Git onto your platform of choice.

Git download page
Git installation instructions for each platform
"""
#%%
"""
1.3.8	Practice Quiz

Question 1
How can a VCS (Version Control System) come in handy when updating your software, even if you’re a solo programmer? Check all that apply.

-Git retains local copies of repositories, resulting in fast operations.
CORRECT.  Git's distributed architecture means each person contributing to a repository retains a full copy of the repository locally.

-If something breaks due to a change, you can fix the problem by reverting to a working version before the change.
CORRECT. With version control, if something goes wrong, we can fix it immediately and figure out what happened later.
Git relies on a centralized server.

Git allows you to review the history of your project.


Question 2
Who is the original creator and main developer of the VCS (Version Control System) tool Git?

Bill Gates
Guido van Rossum
Linus Torvalds
CORRECT. Linus Torvalds developed Git in 2005 to better facilitate the process of developing the Linux kernel with developers across the globe.
James Gosling

Question 3
_____ is a feature of a software management system that records changes to a file or set of files over time so that you can recall specific versions later.

A repository

sys.exit()

Version control
CORRECT. A version control system keeps track of the changes that we make to our files.
IDE

Question 4
A _____ is a collection of edits which has been submitted to the version control system for safe keeping.

IDE

version control system

commit
CORRECT. We call the collection of edits we are making at one time a commit.
repository


Question 5
Within a VCS, project files are organized in centralized locations called _____ where they can be called upon later.

commits

repositories
CORRECT. A repository is a central location in which data is stored and managed.
IDE

yum


"""
# -*- coding: utf-8 -*-
"""
Created on Sun Nov 15 10:58:07 2020

@author: jimko
"""

#%%
"""
Introduction to Git and GitHub, by Google

WEEK 1 – Introduction to Version Control

1.4 Using Git
1.4.1	First Steps with Git
1.4.2   Tracking Files
1.4.3   The Basic Git Workflow
1.4.4   Anatomy of a Commit Message
1.4.5   Reading: Initial Git Cheat Sheet
1.4.6   Practice Quiz

MY SYNOPSIS

contents:
    TELL GIT WHO YOU ARE
    CREATE/CLONE A REPOSITORY
    WORKING TREE/ STAGING AREA/ REPOSITORY
    2 WAYS TO PERFORM A "git commit"
    TRACKED AND UN-TRACKED FILES by Git
    THE COMMAND "git init"
    THE COMMAND "git status"
    THE COMMAND "git add <filename>"
    THE COMMAND "git commit"
    THE COMMAND "git diff filename"
    THE COMMAND "git log"
    THE COMMANDS ls, ls -l, ls -la, ls -l .git/
    EXAMPLE 1
        create directory, create Repository, commit 1 existing file to the Repository
    EXAMPLE 2
        Modify a file already in a Repository, stage it and commit it
TELL GIT WHO YOU ARE
git config --global user.email "me@example.com" # write my email
git config --global user.name "My name"         # write my username

git config --list                               # if I forget I can find the above with this command

CREATE/CLONE A REPOSITORY
Create or Clone a Repository:
git init                                        # create a repository from scratch
git clone                                       # make a clone of a repository (copy a repository) that already exists somewhere else

cd ..                                           # return to parent directory (for my machine it is /c/Users/jimko, I can see it with the pwd command)

WORKING TREE/ STAGING AREA/ REPOSITORY:
Note: a file is first tracked by Git, with the git add command, and then it can be modified/staged/commited
      the "git add" command helps Git to track a file and then stage it
modified    file is in the working tree     (work bench) we work on modified file in our working tree
staged      file is in the staging area     (wheel cart) the changes to the file are ready to be committed / we add files to the staging area
commited    file is in the repository       (storage) store those changes in the VCS

2 WAYS TO PERFORM A "git commit":
git commit                          # with "git commit" we tell Git to save our changes
                                    # this opens the text editor, then we write the commit message
git commit -m 'commit message'      # git commit -m 'Commit Message', does not open the file.
                                    # it allows us to write the commit message on the command line
Attention: Without a Commit Message the commit will be aborted!!                                  
                                    
every time we commit changes, we take another snapshot, which is annotated with a commit message that we can review later.
If multiple -m flags are given to the command, it concatenates the values as separate paragraphs.
 
TRACKED AND UN-TRACKED FILES by Git
when we create a file or store it in a directory, it starts off as untracked.
we will make it tracked with the "git add <filename>" command

 "git add <filename>":
this command changes a file from untracked to tracked by Git
this command changes a file from modified state to staged state
Git will only commit the changes that have been added to the staging area, 
untracked files or modified files that weren't staged will be ignored.

THE COMMAND "git init":
The command can initialize a new, empty repository
The command can convert an existing, unversioned project to a Git repository
(if we just create a directory and navigate to it, with git init we transform the directory into a Repository)

Executing "git init", creates a .git subdirectory in the current working directory, 
which contains all of the necessary Git metadata for the new repository. 
This metadata includes subdirectories for objects, refs, and template files. 
A HEAD file is also created which points to the currently checked out commit.

If you've already run "git init" on a project directory containing a .git subdirectory, 
you can safely run "git init" again on the same project directory. 
The operation is what we call idempotent; running it again doesn't override an existing .git configuration.

THE COMMAND "git status":
This command displays the status of the working tree. 
It also shows   changes that have been staged, 
                changes that haven't been staged, 
                and files that aren't tracked by Git.

THE COMMAND "git add":
This command adds changes from the working tree to the staging area i.e., 
it gathers and prepares files for Git before committing them. 
In other words, it updates the index with the current content found in the working tree 
to prepare the content that's staged for the next commit.

THE COMMAND "git commit"
A Git commit is equivalent to the term "Save"
A commit message is a log message from the user describing the changes

THE COMMAND "git diff filename"
You can see the differences between the older file and the new file. 
New additions are denoted by green-colored text and a + sign at the start of the line. 
Any replacements/removal are denoted by text in red-colored text and a - sign at the start of the line.

THE COMMAND "git log":
Git log command shows the commit history of the repository. 
It shows all the commits on the repository represented by a unique commit ID at the top of each commit. 
It also shows the author, date, and time and the commit message associated with the commits
You also have various options to limit the output of this command. 
The output can be filtered based on the last number of commits, author, commit message, etc. 

THE COMMANDS ls, ls -l, ls -la, ls -l .git/
ls:             display files of the directory
ls -l:          display files of the directory with more details
ls -la:         display files in the directory that start with a dot
ls -l .git/:    display contents of the Repository after it was initialized



EXAMPLE 1 - create directory, create Repository, commit 1 existing file, areas.py in the Repository

mkdir directory2            # create a directory

cd directory2               # navigate to the directory

ls                          # display files of the directory
                            #  no files!

git init                    # create a Repository inside this directory
                            # (Initialized empty Git repository in C:/Users/jimko/directory2/.git/)
                            
ls                          # display files of the directory
                            #  no files!
                            
ls -la                      # display files in the directory that start with a dot
                            # confirm the Repository was created in the directory (it is the .git/) 
                            # total 44
                            # drwxr-xr-x 1 jimko 197609 0 Nov 16 09:57 ./
                            # drwxr-xr-x 1 jimko 197609 0 Nov 16 09:56 ../
                            # drwxr-xr-x 1 jimko 197609 0 Nov 16 09:57 .git/
                          
ls -l .git/                 # display contents of the Repository before adding the areas.py
                            # total 7
                            # -rw-r--r-- 1 jimko 197609  23 Nov 16 09:57 HEAD
                            # -rw-r--r-- 1 jimko 197609 130 Nov 16 09:57 config
                            # -rw-r--r-- 1 jimko 197609  73 Nov 16 09:57 description
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:57 hooks/
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:57 info/
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:57 objects/
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:57 refs/
                            
git status                  # displays status of the Repository
                            # On branch master
                            # No commits yet
                            # nothing to commit (create/copy files and use "git add" to track)
                            # So, we have an empty Repository, no files in there
                            
cp ../areas.py ./areas.py   # copy a file from parent directory to current directory
                            # this file is in the directory but not on the Repository, it is not tracked yet by Git
ls                          # display files of the directory
                            # areas.py
ls -l .git/                 # display contents of the Repository  
                            # exactly same files as above, nothing was added
                            
git status                  # displays status of the Repository
                            # On branch master
                            # No commits yet
                            # Untracked files: (use "git add <file>..." to include in what will be committed)    areas.py
                            # nothing added to commit but untracked files present (use "git add" to track)
                            # So, git understands there is a file in the directory but it is not "tracked" yet!
                               
git add areas.py            # I tell Git to track this file 
                            # I add this file to the staging area 

git status                  # displays status of the Repository
                            # On branch master
                            # No commits yet
                            # Changes to be commited:
                            # (use "git rm --cached <file>..." to unstage)
                            # new file:   areas.py
                            # now the file is inside the Repository but in the staging area so I have to commit it 
                            
git commit                  # opens the nano editor so we can add the Commit Message to our file
                            # [master (root-commit) ed92e57] I am adding areas.py to the Repository of directory2
                            # 1 file changed, 41 insertions(+)
                            # create mode 100644 emails.py
                            # I finally added this file to the Repository
OR git commit -m 'I am adding areas.py to the Repository of directory2'
                            # I do the commit on the command line without an editor

                         
git status                  # displays status of the Repository
                            # On branch master
                            # nothing to commit, working tree clean
                            # the file is in stored in the VCS, no files on working area, no files in staging area
                            


ls                          # I see the contents of the directory, areas.py
ls -l                       # I see the contents of the directory,-rw-r--r-- 1 jimko 197609 270 Nov 16 09:29 areas.py
ls -la                      # I see contents of the directory that start with a dot
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:29 ./
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:24 ../
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:37 .git/
                            # -rw-r--r-- 1 jimko 197609 270 Nov 16 09:29 areas.py

ls -l .git/                 # display contents of the Repository after adding the areas.py
                            # -rw-r--r-- 1 jimko 197609 282 Nov 16 09:34 COMMIT_EDITMSG. THIS IS NEW! is it the areas.py?
                            # -rw-r--r-- 1 jimko 197609  23 Nov 16 09:25 HEAD
                            # -rw-r--r-- 1 jimko 197609 130 Nov 16 09:25 config
                            # -rw-r--r-- 1 jimko 197609  73 Nov 16 09:25 description
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:25 hooks/
                            # -rw-r--r-- 1 jimko 197609 137 Nov 16 09:34 index
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:25 info/
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:34 logs/
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:34 objects/
                            # drwxr-xr-x 1 jimko 197609   0 Nov 16 09:25 refs/

EXAMPLE 2 - Modify a file already in a Repository, stage it and commit it


cd directory2               # navigate to directory
ls -l                       # I see the contents of the directory,-rw-r--r-- 1 jimko 197609 270 Nov 16 09:29 areas.py

git status                  # displays status of the Repository
                            # On branch master
                            # nothing to commit, working tree clean
                            # we will modify the areas.py so this status will change

nano areas.py               # open the areas.py in the nano editor  
                            # modify the areas.py
                            
git status                  # On branch master
                            # Changes not staged for commit:
                            # (use "git add <file>..." to update what will be committed)
                            # (use "git restore <file>..." to discard changes in working directory)
                            # modified:   areas.py
                            # no changes added to commit (use "git add" and/or "git commit -a")
                            # SO: git understands that changes were made to the file and that they are not staged!

git add areas.py            # place the modified file in the staging area

git status                  On branch master
                            Changes to be committed:
                            (use "git restore --staged <file>..." to unstage)
                            modified:   areas.py

git commit -m 'I added a comment'  # commit the staged file to the Repository
                                    # [master 220379b] I added a comment
                                  # 1 file changed, 1 insertion(+)

git status                  On branch master
                            nothing to commit, working tree clean


"""
#%%
"""
1.4.1	First Steps with Git

Let's start by setting some basic configuration. 
A VCS tracks who made which changes, so for this to work, we need to tell Git who we are. 
We can do this by using the Git config command and then setting the values of user.email and user.name to our email 
and our name like this.

We use the dash dash global flag to state that
 we want to set this value for all git repositories that we'd use. 
We could also set different values for different repositories.

GIT BASH APPLICATION:
git config --global user.email "me@example.com"
git config --global user.name "My name"

git init        # create a repository from scratch
git clone       # make a clone of a repository (copy a repository) that already exists somewhere else
                # we will talk about remote repositories later


mkdir checks    # create the directory "checks"
cd checks       # navigate to the directory "checks"
 ~/checks git init        # create a new Repository inside the directory "checks"
Output is:
    Initialized empty Git repository in /home/user/checks/.git/ 
                # we see the directory .git (I see a file folder named "checks", and also a .gitconfig file)
ls -la          # check if the directory .git exists. The ls -la command lists files that start with a dot
Output in video is:
    total 12
    drwxr-xr-x 3 user user 4096 Jan 5 14:18 .
    drwxr-xr-x 29 user user 4096 Jan 5 14:18 ..
    drwxr-xr-x 7 user user 4096 Jan 5 14:18 .git
Output in my machine is:  
total 44
drwxr-xr-x 1 jimko 197609 0 Nov 15 17:45 ./
drwxr-xr-x 1 jimko 197609 0 Nov 15 17:45 ../
drwxr-xr-x 1 jimko 197609 0 Nov 15 17:45 .git/


ls -l .git/     # display contents of the directory ".git"
Output in video is:
    total 32
    drwxr-xr-x 2 user user 4096 Jan 5 14:18 branches
    -rw-r--r-- 1 user user 92 Jan 5 14:18 config
    -rw-r--r-- 1 user user 73 Jan 5 14:18 description
    -rw-r--r-- 1 user user 23 Jan 5 14:18 HEAD
    drwxr-xr-x 2 user user 4096 Jan 5 14:18 books
    drwxr-xr-x 2 user user 4096 Jan 5 14:18 info
    drwxr-xr-x 4 user user 4096 Jan 5 14:18 objects
    drwxr-xr-x 4 user user 4096 Jan 5 14:18 refs

Output in my machine is: 
total 7
-rw-r--r-- 1 jimko 197609  23 Nov 15 17:45 HEAD
-rw-r--r-- 1 jimko 197609 130 Nov 15 17:45 config
-rw-r--r-- 1 jimko 197609  73 Nov 15 17:45 description
drwxr-xr-x 1 jimko 197609   0 Nov 15 17:45 hooks/
drwxr-xr-x 1 jimko 197609   0 Nov 15 17:45 info/
drwxr-xr-x 1 jimko 197609   0 Nov 15 17:45 objects/
drwxr-xr-x 1 jimko 197609   0 Nov 15 17:45 refs/


                # the ".git" directory is a Git directory
                # You can think of it as a database for your Git project that stores the changes and the change history. 
                # it contains files and directories
                # we will not interact with them directly, but through Git commands
                
                # whenever we clone a repository, this Git directory is copied into your computer
                # whenever we create a Repository with git init, a new Git directory is initialized
                # the area outside the Git directory is the working tree
                # the working tree is the current version of your project
                # the working tree is like a workbench where you perform all the modification you want to your file.
                #  This working tree will contain all the files that are currently tracked by Git and any new files that we haven't yet added to the list of track files. 
                # 
                
                
Git directory(.git) and working tree
    The Git directory contains files and directories with which we interact ONLY through git commands
    The git-directory is where the repository resides
    
    Working tree: The work-tree has our source code which we want to be managed by git    

Git directory: contains all the changes and their history
Working tree: contains the current versions of the files

Git makes the distinction between three distinct areas/concepts:
The repository itself, which is stored within the .git directory, as discussed in the previous section
The working tree, which corresponds to the current state of files on your filesystem
The staging area (also called the index), which is the area that you can use to prepare commits / temporarily save your work      

Right now our working tree is empty. 
Let's change that by copying the disk usage, that py file that we saw in an earlier video into our current directory. 

cp ../disk_usage.py   # copy the file "disk_usage.py" into our current directory. 
                      # on my machine:cp ../areas.py ./areas1.py i copied areas.py from previous directory into current directory and gave it a new name too 
                      #(i got an error message with this command cp: missing destination file operand after '../areas.py'

ls -l                 # display contents of the directory
Output in video  is:
    total 4
    -rw-xr-x 1 user user 656 jan 5 14:25 disk_usage.py
Output in my machine is:
    total 1
-rw-r--r-- 1 jimko 197609 270 Nov 15 18:00 areas1.py


                      # We now have file and a working tree but it's currently untracked by Git. 
git add disk_usage.py # To make Git track our file, we'll add it to the project using the git add command
                      # we have added our file to the Staging Area
                      # on my machine git add areas1.py

Staging Area (index)
A file mainted by Git, that contains all of the information
about what files and changes are going to go into your next commit


git status           # use the git status command to get some information about the current working tree and pending changes
Output is:
    On branch master
    No commits yet
    Changes to be commited
    (use "git rm --cached <file>" to unstage)
    new file: disk_usage.py , on my machine it is areas1.py

                    # our change is currently in the staging area

git commit          # when we run this command we tell Git we want to save our changes
                    # this command opens a text editor where we can enter a commit message
                    # nano editor opens
                    # The text that we get tells us that we need to write a commit message and that the change to be committed is the new file that we've added. 
                    # type: Add new disk_usage check save and exit
                    # On Windows, if you use Git Bash the default editor will be Vim. Vim is another text editor, like nano or notepad.

Vim
On Windows, if you use Git Bash the default editor will be Vim. 
Vim is another text editor, like nano or notepad. 
In order to get started Vim there are only a few commands you must remember.
Before making your first commit, try running:
vim
in the terminal.

You start in a mode called “normal mode”. 
You can’t immediately type anything.

In order to get typing press i (stands for insert). This will bring you to “insert mode”, so named because in this mode you can actually type.

When you are done typing press esc. 
This will bring you back to “normal mode”.

In order to save your work you want to type :w 
and press return. 
And in order to exit vim you want to type :q 
and press return. 
Because saving and quitting is a very common action,
there is actually a shortcut :x, which stands for :wq (which just combines :w and :q).

CHANGE FROM VIM TO NANO
git config --global core.editor "nano"
"""

#%%
"""
1.4.2   Tracking Files

any Git project consists of 3 sections
1 git directory contains the history of all files and changes
2 working tree contains the current state of the project, including any changes that we have made
3 staging area contains the changes that have marked to be included in the next commit

 Each time you make a commit, Git records a new snapshot of the state of your project at that moment.
 It's a picture of exactly how all these files looked at a certain moment in time.
 Combined, these snapshots make up the history of your project, and it's information that gets stored in the Git directory. 

When we operate with Git, our files can be either tracked or untracked.
Tracked files are part of the snapshots, while untracked files aren't a part of snapshots yet. 
This is the usual case for new files

Each tracked file can be in one of three main states, 
MODIFIED   
If a file is in the modified state, it means that we've made changes to it that we haven't committed yet. 
STAGED
So, the next step is to stage those changes. 
When we do this, our modified files become stage files. 
In other words, the changes to those files are ready to be committed to the project. 
All files that are staged will be part of the next snapshot we take.
COMMITED
and finally, when a file gets committed, 
the changes made to it are safely stored in a snapshot in the Git directory. 

In other words,
a file tracked by Git, 
will first be modified when we change it in any way. 
Then it becomes staged when we mark those changes for tracking. 
And finally it will get committed when we store those changes in the VCS.

In_Video question:
What do we need to do after modyfying a file tracked by Git?
Answer: we need to stage the file, so that the changes will be included in the next commit

1 cd checks                     # navigate to this directory
2 ~/checks1 (master) ls -l      # display contents of the working tree
Output on my machine:
    total 8
-rw-r--r-- 1 jimko 197609 4428 Nov 15 18:33 find_error.py
3 ~/checks1 (master) git status # display current status of our files
Output on my machine:
    $ git status
    On branch master   # we are on the master branch
    nothing to commit, working tree clean # we will modify our file to change this!
4 ~/checks1 (master) atom find_error.py # open the file and modify it. I added another question mark
5 ~/checks1 (master) git status # 
Output on my machine:
    $ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   find_error.py

no changes added to commit (use "git add" and/or "git commit -a")
6 ~/checks1 (master) git add find_error.py # we will STAGE this change for commit with git add command
7 ~/checks1 (master) git status 
Output on my machine:
    $ git status
    On branch master
    Changes to be committed:
        (use "git restore --staged <file>..." to unstage)
        modified:   find_error.py

When we call git add, 
we're telling Git that we want to add the current changes in that file to the list of changes to be committed. 
This means that our file is currently part of the staging area, and it will be committed once we run 
the next Git command,git commit. 

8 ~/checks1 (master) git commit -m 'I added another question mark'
Output on my machine is:
    [master b43ff7d] I added another question mark
    1 file changed, 1 insertion(+), 1 deletion(-)

So, we've now committed our stage changes. 
This creates a new snapshot in the Git directory. 
The command shows us some stats for the change made.

9 ~/checks1 (master) git status #
Output on my machine is:
    On branch master
    nothing to commit, working tree clean

we have no changes to commit. 
Because the change we made has gone through the full cycle of modified, staged and committed. 

Summary:
So to sum up, we work on modified files in our working tree. 
When they're ready, we staged these files by adding them to the staging area. 
Finally, we commit the changes sitting in our staging area, which takes a snapshot of those files and stores them in the database that lives in the Git directory.
"""
#%%
"""
1.4.3   The Basic Git Workflow

In-Video question
When committing new files or changes with git commit, the user is asked to provide a commit message. 
What will happen if an empty commit message is entered?
Answer: The commit will be aborted

EXAMPLE - create a Repository and add to it the new file "all_checks.py" we just created on the nano editor
mkdir scripts
cd scripts
git init
git config -l
                diff.astextplain.textconv=astextplain
                filter.lfs.clean=git-lfs clean -- %f
                filter.lfs.smudge=git-lfs smudge -- %f
                filter.lfs.process=git-lfs filter-process
                filter.lfs.required=true
                http.sslbackend=openssl
                http.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt
                core.autocrlf=true
                core.fscache=true
                core.symlinks=false
                pull.rebase=false
                credential.helper=manager-core
                credential.https://dev.azure.com.usehttppath=true
                user.email=foteinirodis@gmail.com
                user.name=FoteiniRodi
                core.editor=nano
                core.repositoryformatversion=0
                core.filemode=false
                core.bare=false
                core.logallrefupdates=true
                core.symlinks=false
                core.ignorecase=true

nano all_checks.py
                #!/usr/bin/env python3
                def main():
                    pass
                main()
chmod +x all_checks.py
git status
                On branch master
                No commits yet
                Untracked files:(use "git add <file>..." to include in what will be committed)
                all_checks.py
                nothing added to commit but untracked files present (use "git add" to track)
git add all_checks.py
                This command will immediately move a new file from untracked to stage status
                And as we'll see later, it will also change a file in the modified state to staged state.
                Git will only commit the changes that have been added to the staging area, untracked files or modified files that weren't staged will be ignored.
                warning: LF will be replaced by CRLF in all_checks.py.
                The file will have its original line endings in your working directory
git status
                On branch master
                No commits yet
                Changes to be committed:
                (use "git rm --cached <file>..." to unstage)
                new file:   all_checks.py

git commit      
                nano editor opens
                I write: Create an empty all_checks.py
                Please enter the commit message for your changes. Lines starting with '#' will be ignored, and an empty message aborts the commit.                
                On branch master
                Initial commit
                Changes to be committed:
                new file:   all_checks.py
CTRL-, ENTER, CTRL-X
                [master (root-commit) 7ad8fb4] Create an empty all_checks.py
                1 file changed, 6 insertions(+)
                create mode 100644 all_checks.py

every time we commit changes, we take another snapshot, which is annotated with a commit message that we can review later.


EXAMPLE - Modify the file "all_checks.py", stage it and commit it to the Repository

nano all_checks.py
                modify this file
                #!/usr/bin/env python3
                import os
                def check_reboot():
                    "Returns True if the computer has a pending reboot "
                    return os.path.exist("/run/reboot-required")
                def main():
                    pass
                main()
CTRL-, ENTER, CTRL-X
git status
                git understands there as a change
                On branch master
                Changes not staged for commit:
                  (use "git add <file>..." to update what will be committed)
                  (use "git restore <file>..." to discard changes in working directory)
                        modified:   all_checks.py                
                no changes added to commit (use "git add" and/or "git commit -a")
git add all_checks.py
                we placed the modified file in the staging area
                
git status
                On branch master
                Changes to be committed:
                  (use "git restore --staged <file>..." to unstage)
                        modified:   all_checks.py
git commit -m 'Add a check_reboot function'
                [master 2fa1b5a] Add a check_reboot function
                1 file changed, 4 insertions(+), 1 deletion(-)

"""
#%%
"""
1.4.4   Anatomy of a Commit Message

git log
the command git log displays commit messages
we can check the history of the commits of our project using the git log command.
example
commit 2fa1b5a6fa88e40da6297dc62cab0dfe5b0f9f9e (HEAD -> master)
Author: FoteiniRodi <foteinirodis@gmail.com>
Date:   Mon Nov 16 10:54:57 2020 +0200

    Add a check_reboot function


what makes a good commit message:
Writing a clear informative commit message is important when you use a VCS, for the future you or other developers
 or IT specialists who might read the commit message later on.
They will really appreciate the contextual information as they try and figure out some of the parts of the code or
 configuration.

Sections of a commit message
1st section:
Short description of what the commit changes are about.
Must be Fifty characters or less

2nd section:
Empty line

3rd section:
This text is intended to provide a detailed explanation of what's going on with the change. 
It can reference bugs or issues that will be fixed with the change. 
It can also include links to more information when relevant. 
The line limits can be annoying but they help in making the commit message be more digestible for the reader.
each line under 72 characters

4th section:
all lines start with the # symbol
Just like in Python, this symbol indicates that these lines are comments and
 won't get included in the commit message. 
Git shows them to us whenever we're writing a commit message as a reminder of what files we are about to commit.


In -Video question
What should your commit message look like?
Answer: a short description of the change(up to 50 chars),
followed by one or more paragraphs that give more details of the change (if needed)
"""
#%%
"""
1.4.5   Reading: Initial Git Cheat Sheet

Check out the following links for more information:

The Linux kernel documentation itself, as well as impassioned opinions from other developers. 

You can check out "Setting your email in Git" and "Keeping your email address private" on the GitHub help site for how to do this.
"""

#%%
"""
1.4.6   Practice Quiz

1.
Question 1
Before changes in new files can be added to the Git directory, what command will tell Git to track our file in the list of changes to be committed?
git add
git add will add a file to the staging area and mark it for tracking.
2.
Question 2
Which command would we use to review the commit history for our project?
git log
git log will give us information about the author of each commit, its timestamp, and each commit message.
"""
# -*- coding: utf-8 -*-
"""
Created on Mon Nov 16 11:17:55 2020

@author: jimko
"""

#%%
"""
Introduction to Git and GitHub, by Google

WEEK 1 – Introduction to Version Control

1.5 Qwiklabs Assessment: Introduction to Git

What you'll do:
Create a git repository.
Add files to this repository
Edit the files
Commit the changes to the repository.

This exercise will take place in a Linux Virtual Machine

Contents
    1 - Install Git
    2 - Initialize a new repository
    3 - Configure Git
    4 - Git Operations 1ST COMMIT
    4 - Git Operations 2ND COMMIT


1 - Install Git
Before you install Git on your Linux VM, 
you need to first make sure that you have a fresh index of the packages available to you. 
To do that, run:
    sudo apt update
Now, you can install Git on your Linux host using apt by running the following command:
    sudo apt install git
For any prompts, continue by clicking Y.
Check the installed version of git by using the command below:
    git --version
    Output is:
        git version 2.11.0
        
2 - Initialize a new repository
Create a directory to store your project in. To do this, use the following command:
    mkdir my-git-repo
Now navigate to the directory you created.
    cd my-git-repo
Next, initialize a new repository by using the following command:
    git init

The git init command creates a new Git repository. 
In our case, it transformed the current directory into a Git repository. 
It can also be used to  convert an existing, unversioned project to a Git repository  
                       or to initialize a new, empty repository.
Executing git init creates a .git subdirectory in the current working directory, 
which contains all of the necessary Git metadata for the new repository. 
This metadata includes subdirectories for objects, refs, and template files. 
A HEAD file is also created which points to the currently checked out commit.

with the command ls -l .git/ 
total 44
drwxr-xr-x  2 student-00-fdca6ea99b58 student-00-fdca6ea99b58 4096 Nov 16 15:46 branches                                                                                      anches
-rw-r--r--  1 student-00-fdca6ea99b58 student-00-fdca6ea99b58   26 Nov 16 15:52 COMMIT EDITMSG                                                                                     MMIT_EDITMSG
-rw-r--r--  1 student-00-fdca6ea99b58 student-00-fdca6ea99b58   92 Nov 16 15:46 config                                                                                      nfig
-rw-r--r--  1 student-00-fdca6ea99b58 student-00-fdca6ea99b58   73 Nov 16 15:46 description                                                                                      scription
-rw-r--r--  1 student-00-fdca6ea99b58 student-00-fdca6ea99b58   23 Nov 16 15:46 HEAD                                                                                      AD
drwxr-xr-x  2 student-00-fdca6ea99b58 student-00-fdca6ea99b58 4096 Nov 16 15:46 hooks                                                                                      oks
-rw-r--r--  1 student-00-fdca6ea99b58 student-00-fdca6ea99b58  137 Nov 16 15:52 index                                                                                      dex
drwxr-xr-x  2 student-00-fdca6ea99b58 student-00-fdca6ea99b58 4096 Nov 16 15:46 info                                                                                      fo
drwxr-xr-x  3 student-00-fdca6ea99b58 student-00-fdca6ea99b58 4096 Nov 16 15:49 logs                                                                                      gs
drwxr-xr-x 10 student-00-fdca6ea99b58 student-00-fdca6ea99b58 4096 Nov 16 15:52 objects                                                                                      jects
drwxr-xr-x  4 student-00-fdca6ea99b58 student-00-fdca6ea99b58 4096 Nov 16 15:46 refs                                                                                    fs

                                                                                     

If you've already run git init on a project directory containing a .git subdirectory, 
you can safely run git init again on the same project directory. 
The operation is what we call idempotent; running it again doesn't override an existing .git configuration.

3 - Configure Git
Git uses a username to associate commits with an identity. 
It does this by using the git config command. 
To set Git username use the following command:
    git config --global user.name "Name"
Replace Name with your name. 
Any future commits you push to GitHub from the command line will now be represented by this name. 
You can use git config to even change the name associated with your Git commits. 
This will only affect future commits and won't change the name used for past commits.

Let's set your email address to associate it with your Git commits.
    git config --global user.email "user@example.com"
Replace user@example.com with your email-id. 
Any future commits you now push to GitHub will be associated with this email address. 
You can even use git config to change the user email associated with your Git commits.

4 - Git Operations 1ST COMMIT
Let's now create a text file named README. 
We will be using the nano editor for this.
    nano README
Type any text within the file, or you can use the following text:
This is my first repository.
Save the file by pressing Ctrl-o, Enter key, and Ctrl-x.

Git is now aware of the files in the project. 
We can check the status using the following command:
    git status
This command displays the status of the working tree. 
It also shows changes that have been staged, 
changes that haven't been staged, 
and files that aren't tracked by Git.
Output is:
    On branch master
    initial commit
    Untracked files:
        README
    nothing added to commit but untracked files present (use "git add" to track)

You can now see the file you created, README, under the section Untracked files. 
Git isn't tracking the files yet. 
To track the files, we have to commit these files by adding them to the staging area.

Now let's add the file to the staging area using the following command:
    git add README
This command adds changes from the working tree to the staging area i.e., 
it gathers and prepares files for Git before committing them. 
In other words, it updates the index with the current content found in the working tree 
to prepare the content that's staged for the next commit.

You can now view the status of the working tree using the command: 
    git status.
 This now shows the file README in green i.e., the file is now in the staging area and yet to be committed.
Output is:
    On branch master
    initial commit
    Changes to be commited:
        new file: README
        
However, git add doesn't affect the repository in any serious way 
because changes are not actually recorded until you commit them.

Let's now commit the changes. A Git commit is equivalent to the term "Save".
Commit the changes using the following command:
    git commit
This now opens an editor, asking you to type a commit message. 
Every commit has an associated commit message. 
A commit message is a log message from the user describing the changes.

Enter the commit message of your choice or you can use the following text:
    This is my first commit!
Once you have entered the commit message, save it by pressing Ctrl-o and Enter key. To exit click Ctrl-x.

The git commit command captures a snapshot of the project's currently staged changes i.e., 
it stores the current contents of the index in a new commit along with the commit message.        

You have successfully committed your file!


4 - Git Operations 2ND COMMIT

Let's now re-edit the file again to understand the process better. 
Open the file README using nano editor.
    nano README
Now add another line of description for your repository below the earlier entered line. 
Add the description of your choice or you can use the following text:
    A repository is a location where all the files of a particular project are stored.
Save and exit the editor by pressing Ctrl-o, Enter key, and Ctrl-x.
Now, let's repeat the previous process. 
As mentioned earlier, you can always check the status of your repository by using:
    git status
To understand the difference, compare with the earlier scenario where you added the new file to the repository.
Output is:
    On branch master
    Changes not staged for commit
    modified: README
    no changes added to commit
    
Git tracks the changes and displays that the file has been modified. 
You can view the changes made to file using the following command:
    git diff README
    
    index eb6d976..689076f 100644
    --- a/README
    +++ b/README
    @@ -1 +1,2 @@
    This is my first repository.
    +A repository is a location where all the files of a particular project are stored

You can see the differences between the older file and the new file. 
New additions are denoted by green-colored text and a + sign at the start of the line. 
Any replacements/removal are denoted by text in red-colored text and a - sign at the start of the line.

Now, we will add these changes to the staging area.
    git add README
View the status of the repository using the following command:
    git status
Git now shows the same file in green-colored text. 
This means the changes are staged and ready to be committed.

Let's commit the file now by entering the commit message with the command itself, unlike the previous commit.

    git commit -m "This is my second commit."
The command git commit with -m flag takes the commit message, too. 
This is different to the command without flag, where you had to type the commit message within the editor. 
If multiple -m flags are given to the command, it concatenates the values as separate paragraphs.

To view all the commits use the following command:
    git log
    commit 0dc34ef713fe95f552392b1823b90e4fc05a02e7
    Author: FoteiniRodi <foteinirodis@gmail.com>
    Date:   Mon Nov 16 15:52:02 2020 +0000

    This is my second commit.

    commit 09da39d58acf58b1e84e0a2c75c49dc7e9f9f06a
    Author: FoteiniRodi <foteinirodis@gmail.com>
    Date:   Mon Nov 16 15:48:54 2020 +0000

    This is my first commit!

Git log command shows the commit history of the repository. 
It shows all the commits on the repository represented by a unique commit ID at the top of each commit. 
It also shows the author, date, and time and the commit message associated with the commits.
You also have various options to limit the output of this command. 
The output can be filtered based on the last number of commits, author, commit message, etc. 

"""

# -*- coding: utf-8 -*-
"""
Created on Mon Nov 16 18:22:11 2020

@author: jimko
"""

#%%
"""
Introduction to Git and GitHub, by Google

WEEK 2 – Using Git Locally

2.1 Advanced Git interaction
2.1.1	Intro to Module 2: Using Git Locally
2.1.2	Skipping the Staging Area
2.1.3	Getting More Information About Our Changes
2.1.4	Deleting and Renaming Files
2.1.5	Advanced Git Cheat Sheet
2.1.6	Practice Quiz

MY SYNOPSIS

we have 2 ways to commit a change:
1 - do the change in the file, 
    use "git add" to stage the file, 
    then use "git commit" to commit the file to the VCS
2 - do the change in the file, 
    then use "git commit -a" to stage and commit the file at the same time 

COMMAND "commit -a":        stage and commit in 1 step
COMMAND "commit -m -a":     stage and commit in 1 step. Also add the commit message on the command line

(ofcourse with -m flag, we write the commit message on the command line 
without opening the file on a text editor to write the commit message there)

HEAD indicator is like a bookmark that we can use to keep track of where we are.
HEAD indicator accompanies the latest commit
in general HEAD indicator tells us where we are+++
HEAD is used to indicate what the currently checked-out snapshot is.

COMMAND "git show <commit ID>": we choose to see a specific commit

COMMAND "git log":  shows list of commits. AFTER GIT LOG type q TO EXIT

COMMAND "git log -p": shows associated patches, text is longer

COMMAND "git show <commit ID>": shows a specific commit

COMMAND "git log --stat": shows some stats about the changes in the commit

COMMAND "git diff": for modified but unstaged files
So,     "git diff" is used for Modified files that have not benn staged yet and not commited yet
        "git diff" is used for Modified files to display changes before and after 
        similar to the Linux `diff` command, and can show the differences in various commits
displays the differences between old and new file (after a change we made to the file)
by default,it shows only UNSTAGED changes (so I have not used git add yet to place the file in the staging area)
In other words, git diff works on un-staged files, otherwise its output is nothing

COMMAND "git diff -- staged":   for modified and staged files
                                shows changes that are staged but not commited
                                With this command, we can see the actual stage changes before 
                                we call git commit.
                                An alias to --cached, this will show all staged files compared to the named commit

remember: the sequence is, Modify, Stage, Commit

COMMAND "git add": This command adds changes from the working tree to the staging area i.e., 
                    it gathers and prepares files for Git before committing them. 

COMMAND "git add -p": git will show us the change being added and ASKS US if we want to stage it or not.
                      This way we can detect if there's any changes that we don't want to commit. 
                      Allows a user to interactively review patches to add to the current commit
                      
Attention: "git add * ": stages ALL changes we made while on the working tree

COMMAND "git rm <filename>": deletes a file from the Repository
                             Similar to the Linux `rm` command, this deletes, or removes a file

COMMAND "git mv old-name new-name": to rename files in the Repository
                                    we can also use the mv command to move files between directories
                                    Similar to the Linux `mv` command, this moves a file

COMMAND "git status":   view the status of the working tree
                        shows   tracked files
                                untracked files
                                added files
                                modified files
                                deleted files
                                renamed files
                        git status tells us everyhting about our files
            
.gitignore <file>
we place in that file, everything we want our Repository to ignore
ofcourse we stage it and commit the .gitignore <file>, as with all changes
git add .gitignore then git commit -m 'I added a gitignore file'
The gitignore file is a text file that tells Git which files or folders to ignore in a project

"""
#%%
"""
2.1.1	Intro to Module 2: Using Git Locally
 
Over the course of the next videos, we'll go into much more detail about what we can do with Git. 
  
We'll start by learning some handy shortcuts and how we can get more info out of our version control system. 

Then we'll experience the true power of Git by seeing how we can undo some of our changes. 
The ability to revert previous changes is one of the most useful aspects of version control systems. 
Depending on what needs to be undone, there's a bunch of different techniques that we can use in Git. 
We can discard the changes made to a file, fix a commit that was incorrect and even roll back our project 
to an older snapshot. 

Finally, we'll check out yet another important concept, Branches. 
We can use branches to work on an experimental feature without affecting the main code of our project. 
Support separate versions of a program that can't be merged together and much more.
We'll dive into what branches are, when and how to use them and how to deal with merge conflicts. 
"""
#%%
"""
2.1.2	Skipping the Staging Area

According to the Git workflow, we modify the file, stage it and then commit it.
Here we will see how to stage and commit not in 2 steps but in 1 step

Below we see how to stage and commit in one step
WHEN to do stage and commit in one step, 
    -when we already know that the current changes are the ones that we want to commit
    -when making small changes that we know we'll want to commit directly 
    without keeping them in the staging area and having to write long and complex descriptions. 

We can do stage and commit in one step with "git commit -a"
The flag "-a" automatically stages every file that's tracked and modified before doing the commit
"git commit -a" doesn't work on new files because those are untracked.
Instead, git commit -a, is a shortcut to stage any changes to tracked files and commit them in one step.
If the modified file has never been committed to the repo, we'll still need to use git add to track it first
In the below example, we have the file "all_checks.py" in the Repository "scripts"
We will modify it and then stage and commit it in one step.


COMMAND "git commit -a":
This is a shortcut that,
-stages a tracked, modified file     (places it in the staging area)
AND
-commits the file                    (places it in the Repository)
IN ONE STEP

So, we have 2 ways to commit a change
1 - do the change in the file, use git add to stage the file, then use git commit to commit the file to the VCS
2 - do the change in the file, then use git commit -a to stage and commit the file at the same time 


COMMAND "git commit -a -m"
-a indicates we will do stage and commit for the file in one step
    with -a we skip the staging area. 
    that means we can't add any other changes before creating the commit. 
    So we need to be sure that we have already included everything we want to include in that commit.
-m indicates we will add the commit message directly (without opening text editor)
    the -m flag is used for very short commit messages 

HEAD
HEAD indicator accompanies the latest commit (see example)
Git uses the head alias to represent the currently checked out snapshot of your project.
In this case, the current snapshot is the latest commit in the project.
Also, HEAD indicator can accompany a commit in a different branch of the projec
it's generally easy to think of head as a pointer to the current branch

So, HEAD is used to indicate what the currently checked out snapshot is. 
This is how git marks your place in the project. 
HEAD indicator is like a bookmark that we can use to keep track of where we are.

When you run git commands like diff, branch, or status, 
git will use the head bookmark as a basis for whatever operation it's performing. 
We'll see Head used when we learn how to undo things and perform rollbacks.

In_Video question
If we're making a small change and want to skip the staging step, 
which two flags do we need to add to the git commit command? 
Answer: -m and -a
The -m flag allows us to directly add the commit message to the command.
EXAMPLE
cd scripts
nano all_checks.py              # see previous py file in Week_1_4
                                # I change the file all_checks.py, it needs to be staged and commited
                                # I will use the new command git commit -a, to stage and commit in one step
                                # below I added content after def main, and imported sys module
                                #!/usr/bin/env python3
                                import os
                                import sys
                                def check_reboot():
                                    "Returns True if the computer has a pending reboot "
                                    return os.path.exist("/run/reboot-required")
                                def main():
                                    if check_reboot():
                                        print('Pending Reboot.')
                                        sys.exit(1)
                                
                                main()

git commit -a -m "Call check_reboot from main, exit with 1 on error"
                                # Output is:
                                # [master ef21e4e] Call check_reboot from main, exit with 1 on error
                                # 1 file changed, 4 insertions(+), 1 deletion(-)

git log                         # this displays all commit messages 
                                # latest commit appears on the top
                                commit ef21e4efdae10d9c36a7d306432ce5d505fdb25a (HEAD -> master)
                                Author: FoteiniRodi <foteinirodis@gmail.com>
                                Date:   Tue Nov 17 07:50:38 2020 +0200
                                
                                    Call check_reboot from main, exit with 1 on error
                                
                                commit 2fa1b5a6fa88e40da6297dc62cab0dfe5b0f9f9e
                                Author: FoteiniRodi <foteinirodis@gmail.com>
                                Date:   Mon Nov 16 10:54:57 2020 +0200
                                
                                    Add a check_reboot function
                                
                                commit 7ad8fb48b2e0b775ecc0b90684c45328682bfec8
                                Author: FoteiniRodi <foteinirodis@gmail.com>
                                Date:   Mon Nov 16 10:36:15 2020 +0200
                                
                                    Create an empty all_checks.py


ls -l .git/                     # displays contents of the Repository?
                                total 13
                                -rw-r--r-- 1 jimko 197609  50 Nov 17 07:50 COMMIT_EDITMSG
                                -rw-r--r-- 1 jimko 197609  23 Nov 16 10:24 HEAD
                                -rw-r--r-- 1 jimko 197609 130 Nov 16 10:24 config
                                -rw-r--r-- 1 jimko 197609  73 Nov 16 10:24 description
                                drwxr-xr-x 1 jimko 197609   0 Nov 16 10:24 hooks/
                                -rw-r--r-- 1 jimko 197609 145 Nov 17 07:50 index
                                drwxr-xr-x 1 jimko 197609   0 Nov 16 10:24 info/
                                drwxr-xr-x 1 jimko 197609   0 Nov 16 10:38 logs/
                                drwxr-xr-x 1 jimko 197609   0 Nov 17 07:50 objects/
                                drwxr-xr-x 1 jimko 197609   0 Nov 16 10:24 refs/

"""
#%%
"""
2.1.3	Getting More Information About Our Changes

COMMAND "git log"
shows s list of commits
shows a list of commits in the current Git repository
By default it displays: commit message, author, date of the change

COMMAND "git log -p"
shows associated patches, text is longer
we use the -p flag. 
The p comes from patch, because using this flag gives us the patch that was created.
The format is equivalent to the diff-u output that we saw on an earlier video.
It shows added lines with plus sign + and remove lines with minus sign -. 
Because the amount of text is now longer than what fits on your screen, 
    Git automatically uses a paging tool that allows us to scroll using page up, page down, and the arrow keys.
We still have one commit below the other, but now each commit takes up a different amount of space, 
    depending on how many lines were added or removed in that commit.
Using this option, we can quickly see what changes were made to the files in our repository. 
This can be especially useful if we're trying to track down a change that recently broke our tools.

COMMAND "git show <commit ID>"
we choose to see a specific commit

COMMAND "git log --stat"
This will cause git log to show some stats about the changes in the commit, 
like which files were changed and how many lines were added or removed.

In-Video question
If we want to see a specific commit, which command would we use along with the commit ID?
Answer: git show

CHANGES THAT HAVE NOT BEEN COMMITED YET - COMMAND "git diff"
git diff displays the differencies between old and new file (after a change we made to the file)
git diff by default, shows only UNSTAGED changes.
In other words, git diff works on un-staged files, otherwise its output is nothing

Until now, whenever we've made changes to our files, 
we've either added them to the staging area with git add and committed them with git commit, 
or 
committed them directly using git commit -a. 

This works fine, but it means we have to know exactly which changes we've made. 
Sometimes it can take a while until we're ready to commit.  
But imagine you've been working on adding a new complex feature to a script and it requires thorough testing.
Before committing it, you need to make sure that it works correctly.
So while doing this you find bugs in your code that you need to fix. 
It's only natural that by the time you get to the commit step you don't really remember everything you changed. 

To help us keep track, git gives us the git diff command.
(so with git diff I can see what changes I did to my file before even having my file staged)
git diff shows differences of an un-staged file before and after a change.

lets make a change to the script all_checks.py and then try the command "git diff"
We see that the only change is the extra lines that we've added. 
If our change was bigger and included several files, we could pass a file by parameter 
    to see the differences relevant to that specific file instead of all the files at the same time. 

COMMAND "git add -p"
To review changes before adding them, use the -p flag with the git add command.
When we use this flag, git will show us the change being added and ask us if we want to stage it or not.
This way we can detect if there's any changes that we don't want to commit. 

COMMAND "git diff -- staged"
shows changes that are staged but not commited
With this command, we can see the actual stage changes before we call git commit.


EXAMPLE
git log
                    commit ef21e4efdae10d9c36a7d306432ce5d505fdb25a (HEAD -> master)
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Tue Nov 17 07:50:38 2020 +0200
                    
                        Call check_reboot from main, exit with 1 on error
                    
                    commit 2fa1b5a6fa88e40da6297dc62cab0dfe5b0f9f9e
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Mon Nov 16 10:54:57 2020 +0200
                    
                        Add a check_reboot function
                    
                    commit 7ad8fb48b2e0b775ecc0b90684c45328682bfec8
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Mon Nov 16 10:36:15 2020 +0200
                    
                        Create an empty all_checks.py

git log -p          # amount of text is now longer than what fits on your screen, use page up/page down
                    # exit by pressing :q
                    commit ef21e4efdae10d9c36a7d306432ce5d505fdb25a (HEAD -> master)
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Tue Nov 17 07:50:38 2020 +0200
                    
                        Call check_reboot from main, exit with 1 on error
                    
                    diff --git a/all_checks.py b/all_checks.py
                    index 9424b71..0dcda8d 100644
                    --- a/all_checks.py
                    +++ b/all_checks.py
                    @@ -1,9 +1,12 @@
                     #!/usr/bin/env python3
                     import os
                    +import sys
                     def check_reboot():
                         "Returns True if the computer has a pending reboot"
                         return os.path.exist("/run/reboot-required")
                     def main():
                    -    pass
                    +    if check_reboot():
                    +        print('Pending Reboot.')
                    +        sys.exit(1)
                    
                     main()
                    
                    commit 2fa1b5a6fa88e40da6297dc62cab0dfe5b0f9f9e
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Mon Nov 16 10:54:57 2020 +0200
                    
                        Add a check_reboot function
                    
                    diff --git a/all_checks.py b/all_checks.py
                    index c0d03b3..9424b71 100644
                    --- a/all_checks.py
                    +++ b/all_checks.py
                    @@ -1,5 +1,8 @@
                     #!/usr/bin/env python3
                    -
                    +import os
                    +def check_reboot():
                    +    "Returns True if the computer has a pending reboot"
                    +    return os.path.exist("/run/reboot-required")
                     def main():
                         pass
                    
                    
                    commit 7ad8fb48b2e0b775ecc0b90684c45328682bfec8
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Mon Nov 16 10:36:15 2020 +0200
                    
                        Create an empty all_checks.py
                    
                    diff --git a/all_checks.py b/all_checks.py
                    new file mode 100644
                    index 0000000..c0d03b3
                    --- /dev/null
                    +++ b/all_checks.py
                    @@ -0,0 +1,6 @@
                    +#!/usr/bin/env python3
                    +
                    +def main():
                    +    pass
                    +
                    +main()
                    (END)

git show 2fa1b5a6fa88e40da6297dc62cab0dfe5b0f9f9e 
                    # I have chosen to see a specific commit
                    commit 2fa1b5a6fa88e40da6297dc62cab0dfe5b0f9f9e
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Mon Nov 16 10:54:57 2020 +0200
                    
                        Add a check_reboot function
                    
                    diff --git a/all_checks.py b/all_checks.py
                    index c0d03b3..9424b71 100644
                    --- a/all_checks.py
                    +++ b/all_checks.py
                    @@ -1,5 +1,8 @@
                     #!/usr/bin/env python3
                    -
                    +import os
                    +def check_reboot():
                    +    "Returns True if the computer has a pending reboot "
                    +    return os.path.exist("/run/reboot-required")
                     def main():
                         pass

git log --stat
                    commit ef21e4efdae10d9c36a7d306432ce5d505fdb25a (HEAD -> master)
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Tue Nov 17 07:50:38 2020 +0200
                    
                        Call check_reboot from main, exit with 1 on error
                    
                     all_checks.py | 5 ++++-
                     1 file changed, 4 insertions(+), 1 deletion(-)
                    
                    commit 2fa1b5a6fa88e40da6297dc62cab0dfe5b0f9f9e
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Mon Nov 16 10:54:57 2020 +0200
                    
                        Add a check_reboot function
                    
                     all_checks.py | 5 ++++-
                     1 file changed, 4 insertions(+), 1 deletion(-)
                    
                    commit 7ad8fb48b2e0b775ecc0b90684c45328682bfec8
                    Author: FoteiniRodi <foteinirodis@gmail.com>
                    Date:   Mon Nov 16 10:36:15 2020 +0200
                    
                        Create an empty all_checks.py
                    
                     all_checks.py | 6 ++++++
                     1 file changed, 6 insertions(+)

nano all_scripts.py # I changed it by adding print("Everything ok."), sys.exit(0)
                    #!/usr/bin/env python3
                    import os
                    import sys
                    def check_reboot():
                        "Returns True if the computer has a pending reboot"
                        return os.path.exist("/run/reboot-required")
                    def main():
                        if check_reboot():
                            print('Pending Reboot.')
                            sys.exit(1)
                        print("Everything ok.")
                        sys.exit(0)
                    main()

CTRL-O, ENTER, CTRL-X

git diff            # check out what git diff shows us. This works on modified BUT UNSTAGED FILES
                    # this format is equivalent to the diff -u output that we saw in an earlier video
                    # we see the added lines with a + in front of them
                    diff --git a/all_checks.py b/all_checks.py
                    index 0dcda8d..661bbce 100644
                    --- a/all_checks.py
                    +++ b/all_checks.py
                    @@ -8,5 +8,6 @@ def main():
                         if check_reboot():
                             print('Pending Reboot.')
                             sys.exit(1)
                    -
                    +    print("Everything ok.")
                    +    sys.exit(0)
                     main()

git add -p          # gitshows us the change being added and ASKS us if we want to stage it or not
                    # I answered y yes
                    diff --git a/all_checks.py b/all_checks.py
                    index 0dcda8d..661bbce 100644
                    --- a/all_checks.py
                    +++ b/all_checks.py
                    @@ -8,5 +8,6 @@ def main():
                         if check_reboot():
                             print('Pending Reboot.')
                             sys.exit(1)
                    -
                    +    print("Everything ok.")
                    +    sys.exit(0)
                     main()
                    (1/1) Stage this hunk [y,n,q,a,d,e,?]? y

git diff          # now it does not show any differences, because I staged the modified file with git add above
                  # no output shown
                  
git commit -m 'Added a message when everything is ok'
                  # I modified the file, i used git add to stage it and now I finally commit it  
                 [master 8f10e32] Added a message when everything is ok
                 1 file changed, 2 insertions(+), 1 deletion(-)

"""
#%%
"""
2.1.4	Deleting and Renaming Files

COMMAND "git rm <filename>"
deletes a file from the Repository

COMMAND "git mv old-name new-name"
to rename files in the Repository
the mv command exists in Linux, it can be used for renaming and for moving a file
we can use the mv command to move files between directories

COMMAND git status
the output of git status is a super useful tool to help us know what's up with our files. 
It shows us which files have tracked or untracked changes, and 
which files were added, modified, deleted or renamed.
It's important that the output of these commands stays relevant to what we're doing. 
If we have a long list of untracked files, we might lose an important change in the noise.

.gitignore <file>
If there are files that get automatically generated by our scripts, 
or our operating system generates artifacts that we don't want in our repo, 
we'll want to ignore them so that they don't add noise to the output of git status.
To do this, we can use the gitignore file.


EXAMPLE
cd checks
ls -l
        total 9
        -rw-r--r-- 1 jimko 197609 4428 Nov 17 16:59 find-error.py
        -rw-r--r-- 1 jimko 197609   31 Nov 15 18:16 program.py
git rm program.py
        rm 'program.py'
ls -l
        total 8
        -rw-r--r-- 1 jimko 197609 4428 Nov 17 16:59 find-error.py
git status
        On branch master
        Changes to be committed:
          (use "git restore --staged <file>..." to unstage)
                deleted:    program.py
git commit -m 'Deleted un-needed file'
        # the below output states name of deleted file
        # 1 deletion means there was 1 line in the file
        # and aslo we see the commit message we wrote
        [master 1de27b4] Deleted un-needed file
         1 file changed, 1 deletion(-)
         delete mode 100644 program.py

git mv find-error.py find_allerrors.py
        I changed the name of "find-error.py" to "find_allerrors.py"

git status
        On branch master
        Changes to be committed:
          (use "git restore --staged <file>..." to unstage)
                new file:   find_allerrors.py

git commit -m'New name for find-error.py'
        [master 3e6535b] New name for find-error.py
         1 file changed, 118 insertions(+)
         create mode 100644 find_allerrors.py

.gitignore <file>
Inside this file, we'll specify rules to tell git which files to skip for the current repo.
So, here we specify rules that tell Git to IGNORE certain files

For example, if we're working on an OSX computer, we'll probably want to ignore the dot DS store file, 
which is automatically generated by the operating system. 
To do this, we'll create a .gitignore file containing the name of this file.
Remember that the dot prefix in a Unix-like file system indicates that the file or directory 
is hidden and won't show up when you do the normal directory listing. 
That's why we have to use ls-la to see all files.

cd checks
ls -la
            total 56
            drwxr-xr-x 1 jimko 197609    0 Nov 17 17:13 ./
            drwxr-xr-x 1 jimko 197609    0 Nov 16 10:23 ../
            drwxr-xr-x 1 jimko 197609    0 Nov 17 17:15 .git/
            -rw-r--r-- 1 jimko 197609 4428 Nov 17 16:59 find_allerrors.py

echo .DS_STORE > .gitignore
            the file .gitignore takes its input from +++
ls -la
            total 57
            drwxr-xr-x 1 jimko 197609    0 Nov 17 17:25 ./
            drwxr-xr-x 1 jimko 197609    0 Nov 16 10:23 ../
            drwxr-xr-x 1 jimko 197609    0 Nov 17 17:15 .git/
            -rw-r--r-- 1 jimko 197609   10 Nov 17 17:25 .gitignore
            -rw-r--r-- 1 jimko 197609 4428 Nov 17 16:59 find_allerrors.py

git add .gitignore
            # I added the file to the staging area

git commit -m 'I added a .gitignore file, to ignore .DS_STORE files '
            [master a6a26a4] I added a .gitignore file, to ignore .DS_STORE files
             1 file changed, 1 insertion(+)
             create mode 100644 .gitignore
"""
#%%
"""
2.1.5	Advanced Git Cheat Sheet

Command	Explanation & Link
git commit -a	 Stages files automatically
git log -p	     Produces patch text
git show	Shows various objects
git diff	Is similar to the Linux `diff` command, and can show the differences in various commits
git diff --staged	An alias to --cached, this will show all staged files compared to the named commit
git add -p	Allows a user to interactively review patches to add to the current commit
git mv	Similar to the Linux `mv` command, this moves a file
git rm	Similar to the Linux `rm` command, this deletes, or removes a file
There are many useful git cheatsheets online as well. Please take some time to research and study a few, such as this one.

.gitignore files
.gitignore files are used to tell the git tool to intentionally ignore some files in a given Git repository. 
For example, this can be useful for configuration files or metadata files that a user may not want to check into the master branch. 
Check out more at: https://git-scm.com/docs/gitignore.

A few common examples of file patterns to exclude can be found here.
"""

#%%
"""
2.1.6	Practice Quiz

1.
Question 1
Which of the following commands is NOT an example of a method for comparing or reviewing the changes 
made to a file?

git log -p

git diff --staged

git add -p

git mv
correct. git mv won't give you any information on changes. 
Instead, it is used to move or rename a file or directory in Git.

2.
Question 2
What is the gitignore file?

A file containing a list of commands that Git will ignore.

A file the user is intended to ignore.

A file listing uncommitted changes.

A file containing a list of files or filename patterns for Git to skip for the current repo.
correct.The gitignore file is a text file that tells Git which files or folders to ignore in a project.

3.
Question 3
What kind of file will the command git commit -a not commit?

Tracked files
New files 
correct.  Files that are new and untracked will not be committed before being added.
Old files
Staged files (The git commit -a command will commit all staged files.)

4.
Question 4
What does HEAD represent in Git?

The subject line of a commit message

The top portion of a commit

The currently checked-out snapshot of your project
correct.In all cases, HEAD is used to indicate what the currently checked-out snapshot is.

The first commit of your project

5.
Question 5
If we want to show some stats about the changes in a commit, like which files were changed and how many lines were added or removed, what flag should we add to git log?

--stat
correct. This will cause git log to show some stats about the changes in the commit, like which files were changed and how many lines were added or removed.
--patch

-2

--pretty

"""
# -*- coding: utf-8 -*-
"""
Created on Mon Nov 16 18:24:43 2020

@author: jimko
"""

#%%
"""
Introduction to Git and GitHub, by Google

WEEK 2 – Using Git Locally

2.2 Undoing things
    2.2.1 Undoing Changes Before Committing	
    2.2.2 Amending Commits
    2.2.3 Rollbacks
    2.2.4 Identifying a Commit
    2.2.5 Git Revert Cheat Sheet
    2.2.6 Practice Quiz

MY SYNOPSIS

revert=go back=restore to previous state

COMMAND "git checkout <file>:       reverts a modified but unstaged file
COMMAND "git checkout -p <file>:    reverts individual changes on the modified but unstaged file, 
                                    not all file but certain changes on it.
Attention: git checkout <file>, reverts a file
           git checkout <branch>, switches into this branch 
           
COMMAND "git reset <file>":         reverts a file that is modified and staged
                                    git reset is the OPPOSITE of git add
                                    git reset unstages, git add stages  
                                    "git resert" is useful when by mistake, 
                                    we stage changes that we do not want to commit eventually.
COMMAND "git reset -p <file>":      reverts individual changes
                                    use git reset dash p to get git to ask you which specific changes you want to reset

COMMAND "git add * ":              stages ALL changes we made while on the working tree

COMMAND "git commit --amend":       OVERWRITES THE PREVIOUS COMMIT
                                    for local commits not public commits
                                    AVOID AMENDING COMMITS THAT HAVE ALREADY BEEN MADE PUBLIC

COMMAND "git revert a6a26a480dca83a563bdbf895b9a86e99e4f9420"
                                    reverts a specific commit  
                                    git revert will create a new commit to reverse the previous one

COMMAND "git revert HEAD":          reverts latest commit?
                                    creates a new commit that is the inverse of the previous commit
                                    HEAD indicates we want to revert the latest commit
                                    creates a new commit that is the inverse of the previous commit
                                    Just like that, the bad commit is reverted and the error stopped.
                                    git revert will create a new commit, that is the opposite of everything in the given commit.                                   
COMMAND "git revert a6a26a480dca83a563bdbf895b9a86e99e4f9420" 
                                    reverts a commit that is not the most recent one
                                    
linux command touch <file>: creates a new file
e.g touch auto-update.py                
    touch gather-information.sh

COMMAND "git log -1": git log shows list of commits made
                        -1 shows the latest commit
COMMAND "git log -2": lets us see the 2 latest commits made

COMMAND "git show a6a26a480dca83a563bdbf895b9a86e99e4f9420"
            shows a specific commit
Attention command "git show" without a parameter, shows us information about the commit pointed to by the HEAD.
D.
"""
#%%
"""
2.2.1    Undoing Changes Before Committing

One of the most powerful features of a VCS is that it allows us to REVERT CHANGES
revert change, cancel a change, go back to the immediately precedent state
revert=go back=restore to previous state

1 REVERT UN-STAGED CHANGES, git checkout
revert a file that is modified but not staged


COMMAND "git checkout <file>":
changes a modified but unstaged file, back to its earlier committed state
(Note: my Git Bash names this command as "git restore <file>")


we can use "git checkout <file>" to revert changes to modified files before they get staged. 
This command will restore the file to the latest storage snapshot (which can be either committed or staged).
So if you've made additional changes to a file after you've staged it, 
you can restore the file to the earlier stage version.

COMMAND "git checkout -p <file>"
reverts not the whole Modified file, but individual changes on the file
This command also reverts changes not on the whole file, but treats changes individually
If you need to check out individual changes instead of the whole file, 
you can do that using the dash p flag. 
This will ask you change by change if you want to go back to the previous snapshot or not.


2 REVERT STAGED CHANGES, git reset
revert a file that is modified and staged.
If we realize we've added something to the staging area that we didn't actually want to commit, 
we can unstage our changes by using the git reset command.

COMMAND "git reset ":
    this command is the opposite of git add
    git add, adds changes to the staging area
    git reset, removes changes from the staging area
    
"git resert" is useful when by mistake, we stage changes that we do not want to commit eventually.

COMMAND "git reset -p "++


Staging changes that we don't actually intend to commit happens all the time.
Especially if we use a command like git add star, 
where the star is a file glob pattern used in Bash that expands to all files.
COMMAND " git add * "
This command will end up adding any change done in the working tree to the staging area. 
While sometimes that might be what we want, it can also lead to some surprises.


EXAMPLE for git checkout
cd scripts          # navigate to this directory (we have initialized the Repository earlier)    
nano all_checks.py  # remove the function "check_reboot"
                    def check_reboot():
                        "Returns True if the computer has a pending reboot "
                        return os.path.exist("/run/reboot-required")


./all_checks.py    # run the script
                   #  on my machine I see the message
                   bash: ./all_scripts.py: No such file or directory
                   # on the video:
                   NameError: name 'check_reboot()' is not defined
                   we broke the script with the above change
                   
git status         # git status tells us that our file is modified and the changes aren't staged yet.             
                   # also git status tells us
                   to use git add <file> to stage our changes
                   or to use "git restore <file> to discard our changes
                   
                    On branch master
                    Changes not staged for commit:
                      (use "git add <file>..." to update what will be committed)
                      (use "git restore <file>..." to discard changes in working directory)
                            modified:   all_checks.py
                    
                    no changes added to commit (use "git add" and/or "git commit -a")
                 
git checkout all_checks.py 
                    # We reverted the file to its previous state
                    Updated 1 path from the index

git status
                    # now git status tells us that there is nothing to commit
                    apparently, the previous state of the file was "commited"
                    On branch master
                    nothing to commit, working tree clean

./all_checks.py    # run the script
                   #  on my machine I see the message
                   bash: ./all_scripts.py: No such file or directory
                   # on the video:
                   AttributeError: module 'posixpath' has not attribute 'exist'
                   it is a typing error which we will correct

nano all_checks.py  # open the script and delete "exist" and write "exists"

./all_checks.py         # run the script
                       #  on my machine I see the message
                       bash: ./all_scripts.py: No such file or directory
                       # on the video:
                       Everything ok. (This is the output of the script when it works correctly)

git checkout -p all_checks.py
                    # this command reverts CERTAIN CHANGES
                    diff --git a/all_checks.py b/all_checks.py
                    index 661bbce..49f23aa 100644
                    --- a/all_checks.py
                    +++ b/all_checks.py
                    @@ -3,7 +3,7 @@ import os
                     import sys
                     def check_reboot():
                         "Returns True if the computer has a pending reboot "
                    -    return os.path.exist("/run/reboot-required")
                    +    return os.path.exists("/run/reboot-required")
                     def main():
                         if check_reboot():
                             print('Pending Reboot.')

EXAMPLE for git reset
First, we'll pretend we're trying to debug a problem in our script.
we create a temporary file where we save the output of our file
we do not want to stage this temporary file
by mistake, and by using git add *, we eventually stage this temporary file, how can we undo that?


./all_checks.py > output.txt
                                # run the file, re-direct its output to the txt file
git add *   
                                # add all unstaged changes of our working tree using git add star

git status
                                On branch master
                                Changes to be committed:
                                  (use "git restore --staged <file>..." to unstage)
                                        modified:   all_checks.py
                                        new file:   output.txt
git reset HEAD output.txt 
                                   # output.txt is the file we unstage with git reset
                                   # we are using the HEAD alias, because it indicates the current "snapshot"
                                   I see no output hereof this command

git status                      # I see here that the mistakenly staged output.txt is reverted
                                # It is back to its previous state (previous state=untracked file
                                # remember with git add we 1) track a file and 2) stage a file
                                # track a file = have the file monitored by Git for changes
                                On branch master
                                Changes to be committed:
                                  (use "git restore --staged <file>..." to unstage)
                                        modified:   all_checks.py
                                
                                Untracked files:
                                  (use "git add <file>..." to include in what will be committed)
                                        output.txt
"""
#%%
"""
2.2.2    Amending Commits

amend a commit (commit a file I forgot)
amend a commit message

COMMAND "git commit --amend": 
When we run git commit --amend, 
git will take whatever is currently in our staging area and 
run the git commit workflow to overwrite the previous commit.    
So, "git commit --amend" OVERWRITES THE PREVIOUS COMMIT
Attention: use "git commit --amend" for local commits not public commits ( those that have been pushed to a public or shared repository.)
This is because using --amend re-writes the git history removing the previous commit and replacing it with the amended one. 
This can lead to some confusing situations when working with other people and should definitely be avoided. 
AVOID AMENDING COMMITS THAT HAVE ALREADY BEEN MADE PUBLIC

EXAMPLE 

cd scripts
touch auto-update.py
touch gather-information.sh
ls -l
                            # list the files in the directory
                            # not all files are commited so I cannot say I added them to the Repository
                            total 1
                            -rwxr-xr-x 1 jimko 197609 327 Nov 18 11:47 all_checks.py*
                            -rw-r--r-- 1 jimko 197609   0 Nov 19 06:40 auto-update.py
                            -rw-r--r-- 1 jimko 197609   0 Nov 19 06:40 gather-information.sh
                            -rw-r--r-- 1 jimko 197609   0 Nov 19 06:17 output.txt
git add auto-update.py                         
git commit -m 'I am adding two new scripts'   
                            # I made a mistake on my commit message her
                            # I commited only auto-update.py so I did not add two new scripts,
                            my commit message is wrong
                            [master cdb95c0] I am adding two new scripts
                             1 file changed, 0 insertion(+), 0 deletion(-)
                             create mode 100644 auto-update.py
git add gather-information.sh  
                            # first amend the commit 
                            # commit the second file too
                            
git commit --amend 
                            # this open the text editor
                            # we see the commit message and the stats of the commit 
                            I will add a second line to the exisiting commit message:
                            I am adding two new scripts.
                            gather-information.sh will be used to collect information in case of errors
                            auto-update.py will be run daily to update computers automatically.
                            # Please enter the commit message for your changes. Lines starting
                            # with '#' will be ignored, and an empty message aborts the commit.
                            #
                            # Date:      Thu Nov 19 06:42:54 2020 +0200
                            #
                            # On branch master
                            # Changes to be committed:
                            #       new file:   auto-update.py
                            #       new file:   gather-information.sh
                            #
                            # Untracked files:
                              output.txt
CTRL-O, ENTER, CTRL-X
                            now I see
                            [master 755acd7] I am adding two new scripts. gather-information.sh will be used to collect in
                             Date: Thu Nov 19 06:42:54 2020 +0200
                             3 files changed, 1 insertion(+), 1 deletion(-)
                             create mode 100644 auto-update.py
                             create mode 100644 gather-information.sh

We've amended our previous commit to include both files and a better message                            
BUT we can use git commit --amend, to just update the commit message
                            
"""
#%%
"""
2.2.3    Rollbacks

It is good when we correct our work before doing a "commit".
But what happens if we commit changes and then we want to correct our work?

git revert, is one way to perform a ROLLBACK.
rollback: revert, go back, to code that is working correctly

COMMAND "git revert"
creates a new commit that is the inverse of the previous commit
Just like that, the bad commit is reverted and the error stopped.

Git revert doesn't just mean undo. 
Instead, it creates a commit that contains the inverse of all the changes made in the bad commit 
 in order to cancel them out.
 
e.g. if I added a line in a script on my last commit,
this line will be deleted when I use the command git revert

This way you get the effect of having undone the changes, 
but the history of the commits in the project remains consistent leaving a record of exactly what happened.

So git revert will create a new commit, that is the opposite of everything in the given commit. 
We can revert the latest commit by using the HEAD alias that we mentioned before.  
Since we can think of head as a pointer to the snapshot of your current commit, 
when we pass head to the revert command we tell Git to rewind that current commit

the output of git revert is similar to git commit!This is because the git revert creates a commit for us
                         
Since a revert is a normal commit, we can see both the commit and the reverted commit in the log.                         
                         
EXAMPLE

cd scripts
nano all_checks.py      I open the script and add
                        if disk_full():
                        print("Disk Full.")
                        sys.exit(1)
                       
                        #!/usr/bin/env python3
                        import os
                        import sys
                        def check_reboot():
                            """Returns True if the computer has a pending reboot """
                            return os.path.exists("/run/reboot-required")
                        def main():
                            if check_reboot():
                                print('Pending Reboot.')
                                sys.exit(1)
                            if disk_full():
                                print("Disk Full.")
                                sys.exit(1)
                            print("Everything ok.")
                            sys.exit(0)
                        main()

git commit -a -m 'I added call to a function disk_full'
                        # here I stage and commit my change
                        now the modified file is staged and commited,
                        it contains an error though, I did not test it before commiting it!
                        [master 7506bca] I added call to a function disk_full
                        1 file changed, 3 insertions(+)

./all_checks.py
                        I run the file
                        I get the output
                        NameError: disk_full is not defined
                        This script is not working so we will do a ROLLBACK
                         
git revert HEAD
                        with HEAD we indicate we want to revert our latest commit
                        text editor opens
                        we see the commit interface
                        first line: revert (then the commit message of our latest commit)
                        second line: Git has ADDED A LINE IN THE COMMIT MESSAGE!
                        It defines which commit it reverts, indicating it is a ROLLBACK
                        
                        
                        Revert "I added call to a function disk_full"
                        
                        This reverts commit 7506bca86d70aeffa88386b1c50a0beab668920d.
                        
                        # Please enter the commit message for your changes. Lines starting
                        # with '#' will be ignored, and an empty message aborts the commit.
                        #
                        # On branch master
                        # Changes to be committed:
                        #       modified:   all_checks.py
                        #
                        # Untracked files:
                        
                        It is good practice to add an explanation
                        for WHY we did the ROLLBACK
                        Reason for rollback: the disk_full function was not defined

CTRL-O, ENTER, CTRL-X

after all that, we get the output:
                        [master b32707a] Revert "I added call to a function disk_full"
                         1 file changed, 3 deletions(-)
                         # the output of git revert is similar to git commit!
                         This is because the git revert creates a commit for us
                         Since a revert is a normal commit, we can see both the commit and the reverted commit in the log.

git log -p -2
                        git log shows list of commits
                        latest is shown first
                        -p lets us see the patch created by the commit
                        -2 shows us only 2 latest commits

                        commit b32707a160b942c617ad687ac172b5dc6a0fb1d9 (HEAD -> master)
                        Author: FoteiniRodi <foteinirodis@gmail.com>
                        Date:   Thu Nov 19 07:48:30 2020 +0200
                        
                            Revert "I added call to a function disk_full"
                        
                            Reason for rollback: the disk_full function was not defined
                        
                            This reverts commit 7506bca86d70aeffa88386b1c50a0beab668920d.
                        
                        diff --git a/all_checks.py b/all_checks.py
                        index 140e3ef..49f23aa 100644
                        --- a/all_checks.py
                        +++ b/all_checks.py
                        @@ -8,9 +8,6 @@ def main():
                             if check_reboot():
                                 print('Pending Reboot.')
                                 sys.exit(1)
                        -    if disk_full():
                        -        print("Disk Full.")
                        -        sys.exit(1)
                             print("Everything ok.")
                             sys.exit(0)
                         main()
                        
                        commit 7506bca86d70aeffa88386b1c50a0beab668920d
                        Author: FoteiniRodi <foteinirodis@gmail.com>
                        Date:   Thu Nov 19 07:42:39 2020 +0200
                        
                            I added call to a function disk_full
                        
                        diff --git a/all_checks.py b/all_checks.py
                        index 49f23aa..140e3ef 100644
                        --- a/all_checks.py
                        +++ b/all_checks.py
                        @@ -8,6 +8,9 @@ def main():
                             if check_reboot():
                                 print('Pending Reboot.')
                                 sys.exit(1)
                        +    if disk_full():
                        +        print("Disk Full.")
                        +        sys.exit(1)
                             print("Everything ok.")
                             sys.exit(0)
                         main()

"""
#%%
"""
2.2.4    Identifying a Commit

before, we made a mistake in the latest commit
the latest commit is accompanies by the HEAD alias and we can find the commit by using the HEAD alias

but what can we do when the mistake is in a commit we did a long time ago?
we can find and then revert the faulty past commit by using its ID

a commit ID is a long string e.g.
commit 7506bca86d70aeffa88386b1c50a0beab668920d
the sequence after the name commit is called a HASH
HASH is produced by an algorithm
Why Git uses the HASH and not an arithmetic sequence?
HASH used to guarantee the consistency of our repository
Computing the hash keeps data consistent because it's calculated from all the information that makes up a commit.
The commit message, date, author, and the snapshot taken of the working tree. 
The chance of two different commits producing the same hash, commonly referred to as a collision, is extremely small. 
Remember our discussion about fixing commits with the dash dash amend command? 
Each time we amend a commit, the commit ID will change. 
This is why it's important not to use dash dash amend on commits that have been made public.

The data integrity offered by the commit ID means that 
if a bad disk or network link corrupt some data in your repository, or worse, 
if someone intentionally corrupt some data, Git can use the hash to spot that corruption.

How can you use commit IDs to specify a particular commit to work with, like during a rollback?
see example below at git log -2

EXAMPLE

cd checks
git log -1
            git log shows list of commits made
            -1 shows the latest commit
            commit a6a26a480dca83a563bdbf895b9a86e99e4f9420 (HEAD -> master)
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Tue Nov 17 17:28:24 2020 +0200
            
                I added a .gitignore file, to ignore .DS_STORE files
git log -2
            # lets see the 2 latest commits made
            commit a6a26a480dca83a563bdbf895b9a86e99e4f9420 (HEAD -> master)
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Tue Nov 17 17:28:24 2020 +0200
            
                I added a .gitignore file, to ignore .DS_STORE files
            
            commit 3e6535b49317794d84997309b05a8c0d54251e35
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Tue Nov 17 17:15:57 2020 +0200
            
                New name for find-error.py

git show a6a26a480dca83a563bdbf895b9a86e99e4f9420     
            # I choose to see the commit where I changed the name of the file
            commit a6a26a480dca83a563bdbf895b9a86e99e4f9420 (HEAD -> master)
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Tue Nov 17 17:28:24 2020 +0200
            
                I added a .gitignore file, to ignore .DS_STORE files
            
            diff --git a/.gitignore b/.gitignore
            new file mode 100644
            index 0000000..fd5106f
            --- /dev/null
            +++ b/.gitignore
            @@ -0,0 +1 @@
            +.DS_STORE

git revert a6a26a480dca83a563bdbf895b9a86e99e4f9420
            # now I am not using HEAD to revert the latest commit
            I am using the commit ID to revert a specific commit that is not the latest one
            text editor with the commit interface opens
            I will add a reason for the ROLLBACK
            Rollback reason: the previous name was actually better
            when we generate the rollback, Git automatically icludes
            the ID of the commit we are reverting
            commit b6182f460a56bc015d271ade1f84543442635edf (HEAD -> master)
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Thu Nov 19 08:27:48 2020 +0200
            
                Revert "New name for find-error.py"
            
                Rollback reason: the previous name was actually better
            
                This reverts commit 3e6535b49317794d84997309b05a8c0d54251e35.
            
            diff --git a/find_allerrors.py b/find_allerrors.py
            deleted file mode 100644
            index 53234d9..0000000
            --- a/find_allerrors.py
            +++ /dev/null
            @@ -1,118 +0,0 @@

            
"""
#%%
"""
2.2.5    Git Revert Cheat Sheet

Git Revert Cheat Sheet
git checkout 
    is effectively used to switch branches.

git reset 
    basically resets the repo, throwing away some changes. 
    It’s somewhat difficult to understand, so reading the examples in the documentation may be a bit more useful.

There are some other useful articles online, which discuss more aggressive approaches to resetting the repo.

git commit --amend 
    is used to make changes to commits after-the-fact, which can be useful for making notes about a given commit.

git revert 
    makes a new commit which effectively rolls back a previous commit. It’s a bit like an undo command.

There are a few ways you can rollback commits in Git.

There are some interesting considerations about how git object data is stored, such as the usage of sha-1.

Feel free to read more here:

https://en.wikipedia.org/wiki/SHA-1
https://github.blog/2017-03-20-sha-1-collision-detection-on-github-com/
"""
#%%
"""
2.2.6    Practice Quiz

1.
Question 1
Let's say we've made a mistake in our latest commit to a public branch. 
Which of the following commands is the best option for fixing our mistake?

git revert
git commit --amend
git reset
git checkout -- <file>

My Notes:
    the file is commited, so it is modified and staged and commited
    git checkout, reverts a modified but unstaged file which is not the case here
    public branch means we cannot use git commit --amend, this over-writes the previous commit and erases any history, we use this in a local repository
    git reset is used to unstage changes that we eventually do not want to commit
    I think git revert is correct, it will create a new commit it will inverse the mistake in our latest commit and we can see all information too
Answer: Correct
Nice job! git revert will create a new commit to reverse the previous one, and is the best option for undoing commits on public branches.
2.
Question 2
If we want to rollback a commit on a public branch that wasn't the most recent one using the revert command,
 what must we do?

Use the git reset HEAD~2 command instead of revert
Use the revert command repeatedly until we've reached the one we want
use the commit ID at the end of the git revert command CORRECT.
Use the git commit --amend command instead

Answer: Correct
Nice work! The commit ID is a 40-character hash that identifies each commit.
3.
Question 3
What does Git use cryptographic hash keys for?

To secure project backups
To guarantee the consistency of our repository CORRECT
To encrypt passwords
To identify commits

Answer: Correct
Woohoo! Git doesn't really use these hashes for security. Instead, they’re used to guarantee the consistency of our repository.
4.
Question 4
What does the command git commit --amend do?

Start a new branch
Create a copy of the previous commit
Delete the previous commit
Overwrite the previous commit CORRECT

Answer: Correct
Awesome! The command git commit --amend will overwrite the previous commit with what is already in the staging area.
5.
Question 5
How can we easily view the log message 
and diff output the last commit 
if we don't know the commit ID?

git show correct
git identify
git log
git revert

Answer: Correct
Right on! The git show command without an object parameter specified  will default to show us information about the commit pointed to by the HEAD.
"""
# -*- coding: utf-8 -*-
"""
Created on Mon Nov 16 18:26:17 2020

@author: jimko
"""

#%%
"""
Introduction to Git and GitHub, by Google

WEEK 2 – Using Git Locally

2.3 Branching and Merging
    2.3.1 What is a branch?
    2.3.2 Creating New Branches
    2.3.3 Working with Branches
    2.3.4 Merging
    2.3.5 Merge Conflicts
    2.3.6 Git Branches and Merging Cheat Sheet
    2.3.7 Practice Quiz

MY SYNOPSIS

MASTER BRANCH
default branch, Git creates it for us when a new Repository is initialized
represents the known good state of a project, the current working state

BRANCH
we create this branch
represents an independent line of development in a project
represents our efforts to improve the Master branch
if our efforts are successful then we merge them into the Master branch (incorporate the branch into the Master branch)

What is the purpose of organizing repositories into branches?
Answer: to enable changes to be worked on, without disrupting the most current working state

COMMAND "git branch":               it shows all branches in our Repository
COMMAND "git branch <branch>":      creates a new branch

COMMAND "git checkout <branch>":    switches to this branch
COMMAND "git checkout -b <branch>": creates a new branch and switches into it

Attention: git checkout <file>, reverts a file
           git checkout <branch>, switches into this branch 

Attention:
when we switch from one branch to another, 
we see working tree and commit history of the branch we selected

COMMAND "git branch -d <branch>": -deletes a branch
                                  -if there are changes to this branch, not MERGED to the Master branch,
                                      Git asks us what to do
                                  -if we are sure we want to delete it without merging it then,
                                      run 'git branch -D <branch>'.
COMMAND "git branch -D <branch>": Forcibly deletes the branch                               

COMMAND "git merge <branch>" : merges the branch to the Master branch (branch is incorporated to the Master branch)
                               combines branched data and history together 
                               (we merge a branch to the Master branch)
Attention
when I want to merge a branch into the Master branch,
first i have to switch to the Master branch and THEN do the merge

Attention:
What happens when we merge two branches?
Both branches are pointing to the same commit

Git uses two different algorithms to perform a merge:
    1 fast-forward
    2 three-way merge
My notes for MERGE
1) we have the Master branch
   we create a new branch
   IF we do not make a commit on the Master branch after we create the new branch, then 
   we merge with fast-forward
2) we have the Master branch
   we create a new branch
   IF we do make a commit on the Master branch after we create the new branch, then 
   we merge with three-way 
   2-1) IF the changes were made on different files or different part of the file, merge is successful
   2-2) IF  the changes were made on same file or same part of the file, Git does not know how to merge
        and will raise a MERGE CONFILCT

Merge Conflicts happen when we try to merge a branch into the Master branch,
but we have made a commit on the Master branch AFTER the new branch was created.(three-part merge)
Futhermore, 
the commits (on master branch and on new branch) are due to changes made on the SAME file (or same part of file),
so Git does not know how to do the merge and raises a MERGE CONFLICT
In other words,
both branches we're trying to merge have different edits to the same part of the same file

Attention
What's the advantage of Git throwing a merge conflict error in cases of overlap?
Answer: it prevents loss of work if two lines overlap


COMMAND "git merge --abort":  throw the merge away and start over
                              This will stop the merge and reset the files in your working tree 
                              back to the previous commit before the merge ever happened
                              If there are merge conflicts (meaning files are incompatible), 
                              --abort can be used to abort the merge action.

COMMAND "git log": -display a list of commits that were made
                    -most recent commit appears on top
COMMAND "git log --graph --oneline": displays all commits                    
                                    --graph for displaying commits as a graph
                                    --oneline for displaying one line per commit                    
                                    This format helps us better understand the history of our commits 
                                    and how merges have occurred.
                                    This shows a summarized view of the commit history for a repo.


"""
#%
"""
2.3.1   What is a branch?

BRANCH
it is a pointer to a particular commit
it represents an independent line of development in a project 
(Of which the commit it points to, is the latest link in a chain of developing history)

Branches make it really easy to experiment with new ideas or strategies and projects
When you want to add a feature or fix something, you can create a new branch and do your development there.
You can MERGE back into the master branch, 
    when you've got something you like, or 
    discard your changes without negative impact if they don't work out.
In Git, branches are used all the time, as a part of the normal development workflow.
After using a branch then we merge it to the master branch

MASTER BRANCH
Master branch = current working state
it is the default branch, that Git creates for us when a new Repository is initialized
The master branch is commonly used to represent the known good state of a project
When you want to develop a feature or try something new in your project, 
    you can create a separate branch to do your work without worrying about making mistakes on the MASTER branch

In-Video question
What is the purpose of organizing repositories into branches?
Answer: to enable changes to be worked on, without disrupting the most current working state
"""
#%%
"""
2.3.2   Creating New Branches

COMMAND "git branch"
to list, create, delete and manipulate branches

COMMAND "git branch":                   it shows all branches in our Repository
COMMAND "git branch <new branch>":      creates a new branch
COMMAND "git checkout <new branch>":    switches to the new branch
COMMAND "git checkout -b <new branch>": creates a new branch and switches into it

In-Video question
What does the git checkout -b new branch command do?
Answer: creates a new branch and switches to it

EXAMPLE
cd checks
            navigate to the Repository 

git branch
            list all branches in this Repository
            * master

git branch new-feature
            we are adding the branch "new-feature"
git branch
            list all branches in this Repository
            Our new branch was created based on the value of head
            we are still on the Master branch as indicated by the asterisk
            * master
            new-feature
            
git checkout new-feature
            now we are switching, from the Master branch into the branch "new-feature"
            Switched to branch 'new-feature'
            D       areas1.py
git branch
            list all branches in this Repository
            now we are working on the new branch
            the asterisk is now next to branch "new-feature"
              master
              * new-feature

creating a branch and switching to it immediately is a common task
that is why a command exists to create and switch in one step
git checkout -b <new branch>
      
git checkout -b even-better-feature
            this command helps us create a new branch AND 
            switch into it at the same time
            Switched to a new branch 'even-better-feature'

git branch   
            list all branches in this Repository
            now we are on the branch "even-better-feature"
            * even-better-feature
              master
              new-feature
nano free_memory.py
            open the nano editor, create a new py file


git add free_memory.py

git commit -m 'Add an empty free_memory.py'
            [even-better-feature e2d9221] Add an empty free_memory
             1 file changed, 6 insertions(+)
             create mode 100644 free_memory.py
git log -2
            we display the 2 latest commits
            in the most recent commit,
            we see the HEAD indicator that informs us about the branch
            The branch "even-better-feature" is ahead of the Master branch
            
            in the commit before the most recent,
            we see the other two branches: new-feature and Master
            commit e2d9221962c4e60e1ad7ad41a57ec39dcc180a85 (HEAD -> even-better-feature)
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Sat Nov 21 08:17:22 2020 +0200
            
                Add an empty free_memory
            
            commit b6182f460a56bc015d271ade1f84543442635edf (new-feature, master)
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Thu Nov 19 08:27:48 2020 +0200
            
                Revert "New name for find-error.py"
            
                Rollback reason: the previous name was actually better
            
                This reverts commit 3e6535b49317794d84997309b05a8c0d54251e35.

"""
#%%
"""
2.3.3   Working with Branches

previously, we created a branch ("even-better-feature"), different than the Master branch and 
added a commit to it ("free_memory.py")

when we switch from one branch to another, we see working tree and commit history of the branch we selected

COMMAND "git branch -d <branch>": -deletes a branch
                                  -if there are changes to this branch, not MERGED to the Master branch,
                                      Git asks us what to do
                                  -if we are sure we want to delete it without merging it then,
                                      run 'git branch -D <branch>'.


In-Video question
How does git checkout switch branches?
Answer:by updating the working tree to match the selected branch


EXAMPLE
cd checks
            navigate to the Repository
git status
            display the status of the Repository
            On branch even-better-feature
            nothing to commit, working tree clean
ls -l
            display current contents of our directory
            total 1
            -rwxr-xr-x 1 jimko 197609 53 Nov 21 08:15 free_memory.py*

So, we are in a clean working tree, in the branch "even-better-feature"
and we see the new file "free_memory.py"

git checkout master
            we switch to the Master branch
            Switched to branch 'master'
git log -2
            display latest 2 commits AT THE MASTER BRANCH!!
            commit b6182f460a56bc015d271ade1f84543442635edf (HEAD -> master, new-feature)
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Thu Nov 19 08:27:48 2020 +0200
            
                Revert "New name for find-error.py"
            
                Rollback reason: the previous name was actually better
            
                This reverts commit 3e6535b49317794d84997309b05a8c0d54251e35.
            
            commit fe7688b4007a0a2954b1632fbf0701c7c0b3fd10
            Author: FoteiniRodi <foteinirodis@gmail.com>
            Date:   Thu Nov 19 08:23:56 2020 +0200
            
                Revert "I added a .gitignore file, to ignore .DS_STORE files"
            
                This reverts commit a6a26a480dca83a563bdbf895b9a86e99e4f9420.

When we switch to a different branch using git checkout, 
under the hood, git changes where head is pointing. 
Thanks to this checkout, head went from pointing to the latest commit in the even better feature branch to
 the most recent commit of the master branch.

ls -l
            display current contents of our directory
            total 0
            the "free_memory.py" is not here

This demonstrates that when we switch branches in git, the working directory or working tree and commit history will be changed to reflect the snapshot of our project in that branch.    
My notes: SO, the working directory and commit history are unique to each branch?
Since free memory py was committed on another branch, 
it doesn't show up in the history or working directory of the master branch.
each branch is just a pointer to a specific commit in a series of snapshots

git branch -d
            this deletes a branch

git branch
            list all braches in our Repository
              git branch -d 
            * master
              new-feature

git branch -d new-feature
            this deletes the branch "new-feature"
            Deleted branch new-feature (was b6182f4).

git branch
            list all braches in our Repository
             even-better-feature
            * master
If there are changes in the branch we want to delete that haven't been merged back into the master branch, git will let us know with an error.

git branch -d even-better-feature
              now we try to delete the branch "even-better-feature"
              BUT we get an error
              because there were changes in the branch NOT MERGED into the Master branch
              error: The branch 'even-better-feature' is not fully merged.
              If you are sure you want to delete it, run 'git branch -D even-better-feature'.

"""
#%%
"""
2.3.4   Merging

Merging
term that Git uses for combining branched data and history together
(we merge a branch to the Master branch)

COMMAND ""git merge <branch> : merges the branch to the Master branch
                               combines branched data and history together 
                               (we merge a branch to the Master branch)

In-Video question
What happens when we merge two branches?
Answer: both branches are pointing to the same commit

Git uses two different aldorithms to perform a merge:
    1 fast-forward
    2 three-way merge

FAST-FORWARD MERGE
when all the commits in the checked out branch are also in the branch that's being merged. 
If this is the case, we can say that the commit history of both branches doesn't diverge. 
In these cases, all Git has to do is update the pointers of the branches to the same commit, 
and no actual merging needs to take place.

THREE-WAY MERGE
when the history of the merging branches has diverged in some way, 
and there isn't a nice linear path to combine them via fast-forwarding. 
This happens when a commit is made on one branch AFTER the point when both branches split.
In our case, this could have happened if we made a commit on the master branch 
after creating the other branches.
When this occurs, Git will tie the branch histories together with a new commit. 
And merge the snapshots at the two branch tips with the most recent common ancestor, 
the commit before the divergence. 
To do this successfully, Git tries to figure out how to combine both snapshots. 
If the changes were made in different files, or in different parts of the same file, 
Git will take both changes and put them together in the result. 
If instead the changes are made on the same part of the same file, Git won't know how to merge those changes, 
and the attempt will result in a merge conflict. 

My notes for MERGE
1) we have the Master branch
   we create a new branch
   IF we do not make a commit on the Master branch after we create the new branch, then 
   we merge with fast-forward
2) we have the Master branch
   we create a new branch
   IF we do make a commit on the Master branch after we create the new branch, then 
   we merge with three-way 
   2-1) IF the changes were made on different files or different part of the file, merge is successful
   2-2) IF  the changes were made on same file or same part of the file, Git does not know how to merge
        and will raise a MERGE CONFILCT




EXAMPLE

git branch
                list all braches in our Repository
                OK, we are on the Master branch
                  even-better-feature
                * master
git merge even-better-feature
                we merge the branch "even-better-feature" into the Master branch
                 Updating b6182f4..e2d9221
                Fast-forward
                 free_memory.py | 6 ++++++
                 1 file changed, 6 insertions(+)
                 create mode 100644 free_memory.py
THIS IS A FAST-FORWARD MERGE!

git log
                -display a list of commits that were made
                -in the most recent commit which appears on top:
                the HEAD indicator pints at Master
                and we see that both Master branch and even-better-feature branch 
                are now both pointing to the same commit
                
                commit e2d9221962c4e60e1ad7ad41a57ec39dcc180a85 (HEAD -> master, even-better-feature)
                Author: FoteiniRodi <foteinirodis@gmail.com>
                Date:   Sat Nov 21 08:17:22 2020 +0200
                
                    Add an empty free_memory
                
                commit b6182f460a56bc015d271ade1f84543442635edf
                Author: FoteiniRodi <foteinirodis@gmail.com>
                Date:   Thu Nov 19 08:27:48 2020 +0200
                
                    Revert "New name for find-error.py"
                
                    Rollback reason: the previous name was actually better
                
                    This reverts commit 3e6535b49317794d84997309b05a8c0d54251e35.
                
                commit fe7688b4007a0a2954b1632fbf0701c7c0b3fd10
                Author: FoteiniRodi <foteinirodis@gmail.com>
                Date:   Thu Nov 19 08:23:56 2020 +0200
                
                    Revert "I added a .gitignore file, to ignore .DS_STORE files"
                
                    This reverts commit a6a26a480dca83a563bdbf895b9a86e99e4f9420.
                
                commit a6a26a480dca83a563bdbf895b9a86e99e4f9420
                Author: FoteiniRodi <foteinirodis@gmail.com>
                Date:   Tue Nov 17 17:28:24 2020 +0200
                
                    I added a .gitignore file, to ignore .DS_STORE files
                
                commit 3e6535b49317794d84997309b05a8c0d54251e35
                Author: FoteiniRodi <foteinirodis@gmail.com>
                Date:   Tue Nov 17 17:15:57 2020 +0200
                
                    New name for find-error.py
                
                commit 1de27b413ba68cff8e63c75ea690cfa584ad589a
                Author: FoteiniRodi <foteinirodis@gmail.com>
                Date:   Tue Nov 17 17:04:39 2020 +0200
                
                    Deleted un-needed file
                
                commit 5a8dc2aab9e45ebbd1f899fe95844aa21f6fa421
                Author: FoteiniRodi <foteinirodis@gmail.com>
                Date:   Sun Nov 15 18:17:38 2020 +0200
                
                    Add program.py to checks
                              

"""
#%%
"""
2.3.5   Merge Conflicts

Merge Conflicts happen when we try to merge a branch into the Master branch,
but we have made a commit on the Master branch AFTER the new branch was created.(three-part merge)
Futhermore, 
the commits (on master branch and on new branch) are due to changes made on the SAME file (or same part of file),
so Git does not know how to do the merge and raises a MERGE CONFLICT

In other words,
both the branches we're trying to merge have different edits to the same part of the same file

In-Video question
What's the advantage of Git throwing a merge conflict error in cases of overlap?
Answer: it prevents loss of work if two lines overlap


COMMAND "git merge --abort":  throw the merge away and start over
                              This will stop the merge and reset the files in your working tree 
                              back to the previous commit before the merge ever happened  

COMMAND "git log --graph --oneline": displays all commits                    
                                    --graph for displaying commits as a graph
                                    --oneline for displaying one line per commit                    
                                    This format helps us better understand the history of our commits 
                                    and how merges have occurred.

EXAMPLE- resolve a merge conflict that I created on purpose

cd checks
git branch
                    remember, I merged the branch even-better-feature into the Master branch 
                      even-better-feature
                    * master

nano free_memory.py
                    instead of pass write: Checks if there is enough memory in the computer
                    #!/usr/bin/env python3
                    def main():
                        pass
                    main()
                    #!/usr/bin/env python3
                    def main():
                        Checks if there is enough memory in the computer
                    main()

git commit -a -m 'I added a comment to function main()'
                    now I am adding to staging area
                    and
                    commiting the change IN ONE STEP
                    ALL THIS IN THE MASTER BRANCH

git checkout even-better-feature
                    switch from Master branch to this branch
                    Switched to branch 'even-better-feature'

                    remember "even-better-feature" originally contained the free_memory.py,
                    and we merged it to the Master branch

nano free_memory.py
                    we see the free_memory.py as it originally is
                    because the change we made above was on the Master branch
                    #!/usr/bin/env python3
                    def main():
                        pass
                    main()
                    NOW instead of pass write: print("Everything is OK.") 
                     #!/usr/bin/env python3
                    def main():
                        print("Everything is OK.")
                    main()
                                        
CTRL-O, ENTER, CTRL-X
                    
git commit -a -m 'I added print("Everything is OK.")'
                    now I am adding to staging area
                    and
                    commiting the change IN ONE STEP
                    ALL THIS IN THE "even-better-feature" BRANCH 

git checkout master
                    switch from "even-better-feature" into the Master branch

git merge even-better-feature
                    we try to merge the even-better-feature branch into the Master branch
                    we get the ERROR:
                        
                    Auto-merging free_memory.py
                    CONFLICT (content): Merge conflict in free_memory.py
                    Automatic merge failed; fix conflicts and then commit the result.
                    
                    So, Git cannot merge the branch into the Master branch
                    while on the Master branch, I made change 1 to the py file at the "pass" part
                    while on the even-better-feature branch, I made change 2 to the py file at the "pass" part
                    change 1 is different than change 2
                    therefore Git does not know which change to apply and cannot merge the branch into the Master branch

git status
                    On branch master
                    You have unmerged paths.
                      (fix conflicts and run "git commit")
                      (use "git merge --abort" to abort the merge)
                    
                    Unmerged paths:
                      (use "git add <file>..." to mark resolution)
                            both modified:   free_memory.py
git branch
                    displays all branches
                    we are on the Master branch
                      even-better-feature
                    * master

nano free_memory.py
                    we open the changed file
                    Git has added some information to our files 
                    to tell us which parts of the code are conflicting. 
                    we see HEAD and even-better-feature
                    
                    previously while on the Master branch, deleted pass and added:
                    Checks if there is enough memory in the computer  
                    
                    previously while on the even-better-feature branch,deleted pass and added:
                    print("Everything is OK.")
                    
                    So, Git tells us what we did and where 
                    
                    Finaly we decide to keep BOTH CHANGES
                    and delete the merger markers
                    
                    #!/usr/bin/env python3
                    def main():
                    <<<<<<< HEAD
                        "Checks if there is enough memory in the computer"
                    =======
                        print("Everything is OK.")
                    >>>>>>> even-better-feature
                    main()
                    
                    #!/usr/bin/env python3
                    def main():                
                        "Checks if there is enough memory in the computer"                 
                        print("Everything is OK.")
                    main()
CTRL-O, ENTER, CTRL-X

git add free_memory.py
                    we add the changed file to the staging area

git status
                    On branch master
                    All conflicts fixed but you are still merging.
                      (use "git commit" to conclude merge)
                    
                    Changes to be committed:
                            modified:   free_memory.py

git commit
                    we add the file from the staging area to the Repository    
                    we have not added a Commit Message so the editor opens
                    
                    This looks different than other commits because it is a merge
                    
                    
                    
                    Merge branch 'even-better-feature'
                    
                    # Conflicts:
                    #       free_memory.py
                    #
                    # It looks like you may be committing a merge.
                    # If this is not correct, please run
                    #       git update-ref -d MERGE_HEAD
                    # and try again.
                    
                    
                    # Please enter the commit message for your changes. Lines starting
                    # with '#' will be ignored, and an empty message aborts the commit.
                    #
                    # On branch master
                    # All conflicts fixed but you are still merging.
                    #
                    # Changes to be committed:
                    #       modified:   free_memory.py

now the merge conflict has been resolved

git log --graph --oneline
                    displays all commits
                    --graph for displaying commits as a graph
                    --oneline for displaying one line per commit
                    
                    This format helps us better understand the history of our commits and how merges have occurred.
                    
                    *   48791ed (HEAD -> master) Merge branch 'even-better-feature'
                    |\
                    | * 5368a6f (even-better-feature) I added print("Everything is OK.")
                    * | 2b95dfc I added a comment to function main()
                    |/
                    * e2d9221 Add an empty free_memory
                    * b6182f4 Revert "New name for find-error.py"
                    * fe7688b Revert "I added a .gitignore file, to ignore .DS_STORE files"
                    * a6a26a4 I added a .gitignore file, to ignore .DS_STORE files
                    * 3e6535b New name for find-error.py
                    * 1de27b4 Deleted un-needed file
                    * 5a8dc2a Add program.py to checks
                    * e5b068d Add areas1.py

"""
#%%
"""
2.3.6   Git Branches and Merging Cheat Sheet

Command	Explanation & Link
git branch	             Used to manage branches
git branch <name> 	    Creates the branch
git branch -d <name>	Deletes the branch
git branch -D <name>	Forcibly deletes the branch

git checkout <branch> 	Switches to a branch.
git checkout -b <branch>	Creates a new branch and switches to it.

git merge <branch> 	Merge joins branches together. 
git merge --abort	If there are merge conflicts (meaning files are incompatible), --abort can be used to abort the merge action.
git log --graph --oneline	This shows a summarized view of the commit history for a repo.

"""
#%%
"""
2.3.7   Practice Quiz


Question 1
When we merge two branches, one of two algorithms is used. 
If the branches have diverged, which algorithm is used?

three-way merge CORRECT
fast-forward merge
merge conflict
orphan-creating merge

2.
Question 2
The following code snippet represents the result of a merge conflict. Edit the code to fix the conflict and keep the version represented by the current branch.

<<<<<<<< HEAD
print("Keep me!")
========
print("No, keep me instead!")
>>>>>>> brancho-cucamonga

since we keep the change by the current branch indicated by HEAD,
we will keep "Keep me!" and delete the other
also I will delete the merger markers
so, print("Keep me!")


3.
Question 3
What command would we use to throw away a merge, and start over?

git checkout -b <branch>
git merge --abort CORRECT
git log --graph --oneline
git branch -D <name>

4.
Question 4
How do we display a summarized view of the commit history for a repo, showing one line per commit?

git log --format=short
git branch -D <name>
git log --graph --oneline CORRECT
git checkout -b <branch>

Question 5
The following script contains the result of a merge conflict. 
Edit the code to fix the conflict, so that both versions are included.

def main():
<<<<<<< HEAD
    print("Start of program>>>>>>>")
=======
    print("End of program!")
>>>>>>> improvement-to-the-code

main()

I will just delete the merge markers
def main():
    print("Start of program>>>>>>>")
    print("End of program!")

main()

"""
# -*- coding: utf-8 -*-
"""
Created on Mon Nov 16 18:28:08 2020

@author: jimko
"""

#%%
"""
Introduction to Git and GitHub, by Google

WEEK 2 – Using Git Locally

2.4 Qwiklabs Assessment: Merging Branches in Git

In this lab, you'll use your knowledge of Git and Git commit history
 to check out an existing repo and make some changes to it. 
You'll also test what you learned about rolling back commits after bad changes,
 in order to fix a script in the repo and run it to produce the correct output.

What you'll do
Check the status and history of an existing Git repo
Create a branch
Modify content on the branch
Make rollback changes
Merge the branch

Contents
1 - EXPLORE REPOSITORY
2 - UNDERSTANDING THE REPOSITORY
3 - ADD A NEW FEATURE
4 - FIX THE SCRIPT
5 - MERGE OPERATION
"""
#%%
"""
1 - EXPLORE REPOSITORY
we have the Repository "food-scripts"
it contains two Python scripts and 1 log file

cd ~/food-scripts       # navigate to the Repository
ls                      # list the files on the Repository (directory?)
                        # favorite_foods.log, food_count.py, food_question.py
cat favorite_foods.log  # display content of this file
                        # contains a list of various foods
cat food_count.py       # display content of this file
                        # This script returns a list of each food and the number of times the food appeared in the favorite_foods.log file.
./food_count.py         # run/execute this script
                        # now we see each food with a number of appearances            

cat food_question.py    # display content of this file 
                        # This prints a list of foods and 
                        prompts the user to enter one of those foods as their favorite. 
                        It then returns an answer of how many others in the list like that same food.                   
./food_question.py      # run/execute this script
                        # this script does not work, ERROR!
                        One of your colleagues reports that this script was working fine until the most recent commit. 
                        We'll be fixing this error later during the lab.

2 - UNDERSTANDING THE REPOSITORY
Let's use the following Git operations to understand the workflow of the repository:
    git status
    git log
    git branch

git status
            On branch master
            nothing to commit, working tree clean

git log, shows list of commits
            commit 21cf376832fa6eace35c0bf9e4bae4a3400452e9
            Author: Alex Cooper <alex_cooper@gmail.com>
            Date:   Wed Jan 8 14:09:39 2020 +0530
            
                Rename item variable to food_item.
            
            commit b8d00e33237b24ea1480c363edd972cf4b49eedf
            Author: Alex Cooper <alex_cooper@gmail.com>
            Date:   Wed Jan 8 14:08:35 2020 +0530
            
                Added file food_question.py that returns how many others in the list like that same food.
            
            commit 8d5a3189b88d273ef08286e5074b5e38d616da21
            Author: Alex Cooper <alex_cooper@gmail.com>
            Date:   Wed Jan 8 14:07:15 2020 +0530
            
                Added file food_count.py that returns a list of each food and the number of times each food appears in favorite_foods.log file.
            
            commit 0a202e03e0356d2b5c323e51905d3d06e5e2d0ed
            Author: Alex Cooper <alex_cooper@gmail.com>
            Date:   Wed Jan 8 14:06:21 2020 +0530
            
                Added file favorite_foods.log that contains list of foods.

AFTER git log Enter q to exit DOES NOT WORK

git branch
            * master

git config user.name "foteinirodi"              # Replace Name with your name
                        warning: user.name has multiple values
                        error: cannot overwrite multiple values with a single value
                               Use a regexp, --add or --replace-all to change user.name.

git config user.email "user@example.com" # Replace user@example.com with your email

3 - ADD A NEW FEATURE

git branch improve-output       # create a branch named improve-output
git checkout improve-output     # switch into this branch
Switched to branch 'improve-output'

nano food_count.py              # open the food_count.py to modify it
                                Add the line below before printing for loop
                                print("Favourite foods, from most popular to least popular")
                                #!/usr/bin/env python3
                                # Dictionary to keep track of food likes
                                counter = {}
                                
                                # Open up the favorite foods log and add it to the dictionary
                                with open("favorite_foods.log", "r") as f:
                                    for i in f:
                                        i = i[:-1]
                                        if i not in counter:
                                            counter[i] = 1
                                        else:
                                            counter[i] += 1
                                
                                # Sorts the liked foods in descending order
                                sort_foods = sorted(counter.items(), key = lambda x : x[1], reverse = True)
                                
                                print("Favourite foods, from most popular to least popular")
                                # Prints out the liked foods
                                for i in range(len(sort_foods)):
                                    
                                    print("{}, {}".format(sort_foods[i][0], sort_foods[i][1]))

CTRL-O, ENTER, CTRL-X
./food_count.py                 # run the script 
git add food_count.py           # add the modified file to the staging area (stage the modified file)
git commit -m "Adding a line in the output describing the utility of food_count.py script"
                                # commit the staged file
                                [improve-output f3ab3a6] Adding a line in the output describing the utility of food_count.py script
                                 1 file changed, 3 insertions(+), 1 deletion(-)

Click Check my progress:)
    
4 - FIX THE SCRIPT

./food_question.py             # this script has an error
                               # we run the script to see the error
This script gives us the error: "NameError: name 'item' is not defined" but 
your colleague says that the file was running fine before the most recent commit they did.
In this case, we'll revert back the previous commit.                              

git log                        # shows list of commits
                               #  see the commits in reverse chronological order
                               # find the commit having "Rename item variable to food_item" as a commit message
                               #  Make sure to note the commit ID for this particular commit.
                               # Enter q to exit.
                                commit f3ab3a668e46ba3639f97b1eb5232261b12bf4d2
                                Author: FoteiniRodi <foteinirodis@gmail.com>
                                Date:   Sat Nov 21 16:53:37 2020 +0000
                                
                                    Adding a line in the output describing the utility of food_count.py script
                                
                                commit 21cf376832fa6eace35c0bf9e4bae4a3400452e9
                                Author: Alex Cooper <alex_cooper@gmail.com>
                                Date:   Wed Jan 8 14:09:39 2020 +0530
                                
                                    Rename item variable to food_item.
                                
                                commit b8d00e33237b24ea1480c363edd972cf4b49eedf
                                Author: Alex Cooper <alex_cooper@gmail.com>
                                Date:   Wed Jan 8 14:08:35 2020 +0530
                                
                                    Added file food_question.py that returns how many others in the list like that same food.
                                
                                commit 8d5a3189b88d273ef08286e5074b5e38d616da21
                                Author: Alex Cooper <alex_cooper@gmail.com>
                                Date:   Wed Jan 8 14:07:15 2020 +0530
                                
                                    Added file food_count.py that returns a list of each food and the number of times each food appears in favorite_foods.log file.
                                
                                commit 0a202e03e0356d2b5c323e51905d3d06e5e2d0ed
                                Author: Alex Cooper <alex_cooper@gmail.com>
                                Date:   Wed Jan 8 14:06:21 2020 +0530
                                
                                    Added file favorite_foods.log that contains list of foods.
                               
git revert [commit-ID]         # I paste the commit ID from above
                               # I will revert this commit
                               # git revert will create a new commit to reverse the previous one
                               # creates a new commit that is the inverse of the previous commit


                                Revert "Rename item variable to food_item."
                                
                                This reverts commit 21cf376832fa6eace35c0bf9e4bae4a3400452e9.
                                
                                # Please enter the commit message for your changes. Lines starting
                                # with '#' will be ignored, and an empty message aborts the commit.
                                # On branch improve-output
                                # Changes to be committed:
                                #       modified:   food_question.py
                                #
This creates a new commit again. 
You can continue with the default commit message on the screen or add your own commit message.

CTRL-O, ENTER, CTRL-X

./food_question.py             # run the script to see  if it runs correctly

5 - MERGE OPERATION

git checkout master             # before merging the branch "improve-output" into the Master branch,
                                PLEASE SWITCH TO THE MASTER BRANCH
git merge improve-output        # now merge it
                                
Now, all your changes made in the improve-output branch are on the master branch.

./food_question.py              # run the script

git status                     # working tree clean

git log

Click Check my progress 
"""







# -*- coding: utf-8 -*-
"""
Created on Sun Nov 22 11:42:24 2020

@author: jimko
"""
#%%
"""
Introduction to Git and GitHub, by Google

WEEK 3 - Working with Remotes

3.1 Introduction to GitHub
    3.1.1 Intro to Module 3: Working with Remotes
    3.1.2 What is GitHub?
    3.1.3 Basic Interaction with GitHub
    3.1.4 Basic Interaction with GitHub Cheat-Sheet
    3.1.5 Practice Quiz

MY SYNOPSIS
Git is a distributed version control system. 
Distributed means that: each developer has a copy of the whole repository on their local machine.

GitHub is an online service
GitHub hosts Git repositories

create a remote repository on GitHub (name it, provide description of use, initialize with a readme)
copy the URL of the remote repository
on my machine, on the Linux command line write

git clone URL  # clones/copies the remote repository to my machine
               # a directory with same name is created on my machine
               # the directory contains the working tree of the remote repository
cd  health-checks
               # navigate to the created directory
ls -l          # display contents (only a readme file)
nano README.md # add a line here
CTRL-O, ENTER, CTRL-X
git commit -a -m 'I Added a line in the README.md'
               # I did git add, git commit for the local repository
               # I updated my local repository woth the change
git push       # I updated my remote repository too

git pull       # when a change is commited to the remote repository
               I pull it to the local repository to update it

COMMAND "git clone URL": copy a remote repository to my machine (create a local repository)
                         clone a remote repository into a local workspace
COMMAND "git push":      update remote repository for changes made to the local repository
                         push commits from your local repo to a remote repo 
COMMAND "git pull":      update local repsitory for changes made to the remote repository
                         fetch the newest updates from a remote repository 
"""
#%%
"""
3.1.1 Intro to Module 3: Working with Remotes

Until we have used Git LOCALLY
Now, we will learn about GitHub and remote repositories
Being able to use remote repositories allows us to effectively collaborate with others.
Using a version control system like Git 
lets us incorporate the work of different people no matter where they are or when they're working.
"""
#%%
"""
3.1.2 What is GitHub?

Git is a distributed version control system. 
Distributed means that: each developer has a copy of the whole repository on their local machine.

Each copy is a peer of the others. 
But we can host one of these copies on a Git server 
and then use it as a remote repository for the other copies. 
This lets us synchronize work between copies through this server.

If we do not want to to set up a Git server yourself and host your repositories, 
you can use an online service like GitHub.

GitHub is an online service
GitHub is a web-based, Git repository hosting service. 
GitHub hosts Git repositories
In addition to what Git offers, GitHub extra features like 
    bug tracking, 
    wikis, and 
    task management
    
GitHub lets us share and access repositories on the web 
and copy or clone them to our local computer, so we can work on them.    

Other options except GitHub are BitBucket, and GitLab.

On GitHub we can have either a private or a public Repository

Attention: to avoid hackers,  use a secure and private Git server, and limit the people authorized to work on it.

In_video question
Which BEST describes GitHub?
It is a remote repository hosting service for Git
"""
#%%
"""
3.1.3 Basic Interaction with GitHub

Go to https://github.com and create an account

Create a Remote Repository on GitHub
provide a name for the Repository
provide a description of what the Repository will be used for
select Public or Private Repository
Initialize the Repository with a readme file, a gitignore file, a license file

    health checks
    Scripts that check the health of our computers
    private Repository
    initialize with a readme file

Create a local copy of the Repository
Go to Code, then copy the URL
Command "git clone" followed by the URL of the repo.
GitHub conveniently lets us copy the URL from our repo from the interface so that we don't have to type it.
We are now ready to clone this Repository from GitHub to our computer

In_Video question
After making changes to our local repository, how do we update the remote repository to reflect our changes?
Use the git push command to send snapshots to the remote repository

EXAMPLE
create remote repository
clone it to our machine, then on the linux command line

git clone URL        # copy the remote repository in my machine
                     # GitHub will ask for our username and password
                     # HERE the credentials manager opened
                     
Since the repository is called health checks, 
a directory with that name was automatically created for us 
and now has the working tree of the Repository in it.

cd health-checks/   # navigate to this directory
ls -l               # display contents of directory
                    # the Repository contains only the readme file that GitHub created for us
                    # README.md this file is in a special format called "markdown"
                    total 1
                    -rw-r--r-- 1 jimko 197609 65 Nov 22 12:52 README.md

nano README.md      # open the readme and add content
                    This repository will be populated with lots of fancy checks
CTRL-O, ENTER, CTRL-X
now we have to do git add and git commit

git commit -a -m 'I Added a line in the README.md'
                    # this command adds and commits in 1 step
                    [main 1506ac7] I Added a line in the README.md
                    1 file changed, 1 insertion(+)
                    
So, I have updated my local repository
I have to update the remote repository too
I will do that with git push

git push            # updates remote repository
                    # GitHub will ask for our username and password
                    # if we check our repository on GitHub, we should see the updated message.
                    Enumerating objects: 5, done.
                    Counting objects: 100% (5/5), done.
                    Delta compression using up to 4 threads
                    Compressing objects: 100% (2/2), done.
                    Writing objects: 100% (3/3), 355 bytes | 177.00 KiB/s, done.
                    Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
                    To https://github.com/FoteiniRodi/health-checks.git
                       5fb21ea..1506ac7  main -> main

success, I pushed the change on my local repository TO the remote repository on GitHub

How to avoid GitHub asking for our username and password
1 One way is to create an SSH key pair and store the public key in our profile,
 so that GitHub recognizes our computer. 
2 Another option is to use a credential helper which caches our credentials for a time window 
so that we don't need to enter our password with every interaction. 
Git already comes with a credential helper baked in. 
We just need to enable it. 
We do that by calling git config - - global credential.helper cache.

git config - - global credential.helper cache
                     # enable the credential helper
                     # enter our credentials once more
                     after that they will be cached for 15 minutes
                     
git pull             # to retrieve new changes from the repository
                     # we will try this to see if credential helper works
                     # enter our credentials once more
                     after that they will be cached and we will not enter them again                  
"""
#%%
"""
3.1.4 Basic Interaction with GitHub Cheat-Sheet

Basic Interaction with GitHub Cheat-Sheet
There are various remote repository hosting sites:

GitHub
BitBucket
Gitlab.
Follow the workflow at https://github.com/join to set up a free account, username, and password. After that, these steps will help you create a brand new repository on GitHub.

Some useful commands for getting started:

Command	Explanation & Link
git clone URL	Git clone is used to clone a remote repository into a local workspace
git push	Git push is used to push commits from your local repo to a remote repo
git pull	Git pull is used to fetch the newest updates from a remote repository
This can be useful for keeping your local workspace up to date.

https://help.github.com/en/articles/caching-your-github-password-in-git
https://help.github.com/en/articles/generating-an-ssh-key  
"""
#%%
"""
3.1.5 Practice Quiz

Question 1
When we want to update our local repository to reflect changes made in the remote repository, 
which command would we use?

git clone <URL>
git push
git pull CORRECT
git commit -a -m

Question 2
git config --global credential.helper cache 
allows us to configure the credential helper, which is used for ...what?

Troubleshooting the login process
Dynamically suggesting commit messages
Allowing configuration of automatic repository pulling
Allowing automated login to GitHub CORRECT

Question 3
Name two ways to avoid having to enter our password 
when retrieving and when pushing changes to the repo. (Check all that apply)

Implement a post-receive hook
Use a credential helper CORRECT
Create an SSH key-pair CORRECT
Use the git commit -a -m command.

Question 4
Before we have a local copy of a commit, we should download one using which command?

git commit -a -m
git push
git pull
git clone <URL> CORRECT

"""
# -*- coding: utf-8 -*-
"""
Created on Sun Nov 22 11:43:59 2020

@author: jimko
"""
#%%
"""
Introduction to Git and GitHub, by Google

WEEK 3 - Working with Remotes

3.2 Using a Remote Repository
    3.2.1 What is a remote?
    3.2.2 Working with Remotes
    3.2.3 Fetching New Changes
    3.2.4 Updating the Local Repository
    3.2.5 Git Remotes Cheat-Sheet
    3.2.6 Practice Quiz

MY SYNOPSIS

a user creates a remote repository (on GitHub or on a server of a private network-Linux OS/Window OS)
other users clone the remote repository and they have local repositories
then, all users collaborate

When working on my local repository, the sequence of steps is:
    modify file
    stage file
    commit file
    pull changes made on the remote (Git lets me know I must update my local if changes have been made to the remote)
    merge
    push changes I made on my local repository to the remote
    FIRST PULL THEN PUSH!
    (merges are done automatically gy Git unless there is a conflict)
    creator of remote repository can have me read-only the remote or give me access

COMMAND "git clone URL":
    I clone/copy the remote repository(URL) to my machine and what I get is a local repository

COMMAND "git remote" 	
    Lists remote repositories
    output to this command is "origin"

COMMAND "git remote -v":   
    Lists remote repositories verbosely (with more details, more words)
    displays configuration of the remote repository
    I see two URL's, one to fetch data from the remote, one to push data to the remote 

COMMAND "git remote show":
    displays remote repositories
    Output to this command is "origin"
    
COMMAND "git remote show origin": 
    "git remote show <repository>" : "git remote show origin"
    displays information about the remote repository e.g. the 2 URL's for fetch and push
    lets us know if those changes are not reflected to our local repository
    
Remote repositories have the name "origin" assigned to them
I can have more than one repository in one directory


COMMAND "git fetch": 
    -fetches changes from the remote repository BUT DOES NOT merge them to our local repository
    -displays commits made on the remote branches but those commits are not reflected yet on our local branches
    -with git fetch we only display the changes done to the remote, 
    if we want those changes applied to our local we have to do it ourselves with git merge
    -Instead of using git fetch then git merge, we can use one command, the git pull

I do not understand the difference of "git fetch" and "git remote update" ADD EXPLANATION ++++++
(on Git Bash, git fetch output is empty and git remote update output is Fetching origin)

COMMAND "git pull": 
    fetches changes from the remote repository AND merges them to our local repository
    (git pull = git fetch + git merge)
                                                                   
COMMAND "git log origin/master": 
    displays history of commits on the remote repository
    displays commits done on the remote master branch (master branch is now named main branch)
                                 
COMMAND "git status": 
    displays status of our changes both in remote and local repository
    lets us know if local branches are behind the remote branches
                      
COMMAND "git merge origin/master":  
    merges the origin/master branch (the remote), into our local master branch

COMMAND "git log": 
    displays history of commits in our local repository
    
COMMAND "git branch -r":
    lists remote branches 
    can be combined with other branch arguments to manage remote branches
    remote branches are read-only
    If we want to make a change to a remote branch, then
    -Pull the remote branch
    -merge it with the local branch
    -push it back to its origin  
    
What TYPE OF MERGE creates a new merge commit?
An explicit merge creates a new merge commit. 
This alters the commit history and explicitly shows where a merge was executed.
"""
#%%
"""
3.2.1 What is a remote?

first I create a Remote Repository on GitHub
then I clone it as a Local Repository on my machine

then I can do whatever changes I like on my Local Repository
if more people clone the Remote Repository on their machine:
    we can use git push to update changes made to the local repository TO the remote
    we can use git pull to update changes made to the remote repository TO our local

Ways to host remote repositories
1) Use GitHub, GitLab (online hosting of the remote repositories)
2) We can set up a Git server in our own network  
    a Git server can run on any OS, Linux, Windows, Mac
    a Git server on our own network offers privacy, control and customization

Using Git to manage a project helps us collaborate successfully. 
Everyone will develop their piece of the project independently, in their own local repositories
Occasionally they'll push finished code into a central remote repository 
where others can pull it and incorporate it into their new developments.
If someone has updated a repository since the last time you synchronize your local copy, 
Git will tell you that it's time to do an update

we push code to the remote repository
we pull code from the remote repository
Git merges branches to the main branch automatically 
if there is a confilct, Git asks us to give instructions for the merge

steps:
modify file
stage file
commit file
then pull code from remote repository, (fetch any changes made), merge if necessary
then push code to the remote repository
SO, first pull and then push

In-Video question
What will happen if the master repository receives a major update since the last local copy was synced?
Git will let you know it is time for an update

How to connect to a remote repository 
HTTP protocol   allows read access to the remote repository
                lets people clone it BUT does not allow them to push changes to it
                
HTTPS protocol allows push by other people but after authenticating them, after creator of remote repository gives access
SSH protocol    same as HTTPS
"""
#%%
"""
 3.2.2 Working with Remotes
 
git clone URL       # I have cloned the remote repository health-cheks 
                      to my local machine.
                      Now I have a local repository in a directory named "health_checks"
cd health-checks   # navigate to the local repository
git remote -v      # displays configuration of the remote repository
                    origin  https://github.com/FoteiniRodi/health-checks.git (fetch)
                    origin  https://github.com/FoteiniRodi/health-checks.git (push)
                    we see the URL's associated with the remote repository
                    there are 2 URL's: one to fetch data from the remote
                                       one to push data to the remote
in some cases, you can have the fetch URL use HTTP for read only access, and the push URL use HTTPS or SSH for access control. 
This is fine as long as the contents of the repo that you read when fetching 
are the same that you write to in pushing. 

Remote repositories have a name assigned to them, by default, the assigned name is origin. 
This lets us track more than one remote in the same Git directory.
(I can have more than 1 repositories in the same Git directory)

git remote show origin # displays information about the remote repository
                        * remote origin
                          Fetch URL: https://github.com/FoteiniRodi/health-checks.git
                          Push  URL: https://github.com/FoteiniRodi/health-checks.git
                          HEAD branch: main
                          Remote branch:
                            main tracked
                          Local branch configured for 'git pull':
                            main merges with remote main
                          Local ref configured for 'git push':
                            main pushes to main (up to date)
For now we only have a main branch that exists locally and remotely
Once you start having more branches, especially different branches in the local and remote repo, this information starts becoming more complex.

git branch -r          # displays remote branches 
                       Git uses remote branches to keep copies of the data that's stored in the remote repository.
                        origin/HEAD -> origin/main
                        origin/main
                        remote branches are read-only
                        we can look at their commit history BUT we can't make changes to them directly
                        To modify the content of remote branches we have to
                        use the steps we mentioned before: 
                            1 pull new changes to our local branch
                            2 merge them with our changes
                            3 push our changes to te remote repository

In-Video question
If we want to make a change to a remote branch, what must we do?
Pull the remote branch
merge it with the local branch
push it back to its origin

git status           # displays status of our changes both in remote and local repository
                       we can use  git status to display the status of our changes in remote branches as well.
                    Now that we are working with a Remote repository AND our Local repository,
                    git status gives us additional information:
                    It tells us that 
                    our branch is up to date with the origin/master branch, 
                    which means that the master branch in the remote repository called origin, has the same commits as our local master branch.
                    On branch main
                    Your branch is up to date with 'origin/main'.
                    
                    nothing to commit, working tree clean
"""
#%%
"""
3.2.3 Fetching New Changes

git pull AND git fetch difference:
git pull fetches and merges / git fetch fetches but does not merge

We can use git fetch to review the changes that happen in the remote repository. 
If we're happy with them, we can use git merge to integrate them into the local branch. 

Fetching commits from a remote repository and then merging them into your local repository 
is such a common operation in Git that there's a handy command to let us do it all in one action, the git pull command

In_Video question
What’s the main difference between git fetch and git pull?
git fetch, fetches remote updates but DOES NOT MERGE.
git pull, fetches remote updates AND MERGES


EXAMPLE
I have the directory health-checks
I cloned before the remote repository health-checks
so I have a local repository

colleague Blue kale added 2 files to the remote repository
I could see the changes on GitHub but I will do it through my command line

git remote show origin # displays information about the remote repository
                        I see: "local branches out of date" 
                        This happens when there are commits done to the remote repository
                        not yet reflected to the local repository
                        
Git does not synchronize remote branches and local branches automatically                        
It waits for us to do it when we are ready
To synchronize we use the "git fetch" command
This command copies the commits done in the remote repository to the remote branches, 
so we can see what other people have committed.

git fetch             #  fetches changes from the remote repository
                         those changes are NOT automatically mirrored to our local branches
                        Fetched content is downloaded to the remote branches on our repository. 
                        So it's not automatically mirrored to our local branches. 

git checkout <branch> # switch to a certain branch

git log origin/master # git log displays history of commits
                        git log origin/master displays commits done on the remote master branch
                        origin is used to look at the remote branch
                        master is the branch
                        -latest commit is on remote master branch (indicated by HEAD) (origin/master)
                        -previous commit is on local master branch (indicated by HEAD)

git status            # displays status of our changes both in remote and local repository
                      Git tells us 
                      Your branch is behind rigin/master by 1 commit
                      Now we can merge the origin/master branch (the remote),
                      into our local master branch

git merge origin/master # merges the origin/master branch (the remote),
                      into our local master branch
                      updating
                      Fast-Forward
                      all_checks.py
                      disk_usage.py+++

git log               # displays history of commits in our local repository
                      latest commit contains local and remote branch both indicated by HEAD                   
                      now our local master branch is up to date with the remote master branch (origin/branch)
"""
#%%
"""
3.2.4 Updating the Local Repository

git pull
Running git pull will fetch the remote copy of the current branch and automatically 
try to merge it into the current local branch.
git pull precedes git push!


Let's see if any changes are made to the remote repository with git pull

git pull       # fetches changes from the remote to the local
               and tries to merge them into the local repository
               Output contains output of git fetch and git merge commands

git log -p -1  # display history of commits
               p is patch (displays more info)
               -1 is latest one commit
               text editor opens, we see the info
               exit the editor with q
               there was a new remote branch called experimental
               that means our colleague Blue Kale started working on a new feature on that branch
               
git remote show origin # displays information about the remote repository
                       we see the new branch called "experimental"
                       we do not have a local branch that reflects the "experimental"
                       
git checkout experimental # with git checkout we switch into a branch
                          Git copies the contents of the remote "experimental" branch
                          to a local branch
                          Branch 'experimental" set up to track remote branch "experimental" from "origin"
                          Switched to a new branch 'experimental'.
                          So we copied it to our local repository and switched into it
                          Now we're all set to work on the experimental feature together with our colleague. 

In-Video question
Assuming no merge conflicts, which type of merge does git pull perform automatically?
Fast-Forward merge

with git pull,
we got the contents of the "experimental" branch
we got the contents of the master branch
merged changes onto the master branch

with git remote update
get the contents of the "experimental" branch
get the contents of the master branch
NO AUTOMATIC merging though

git fetch / git remote update / git pull


"""
#%%
"""
3.2.5 Git Remotes Cheat-Sheet

Git Remotes Cheat-Sheet
Command	Explanation & Links
git remote 	                Lists remote repos
git remote -v	            List remote repos verbosely
git remote show <name>	    Describes a single remote repo
git remote update	        Fetches the most up-to-date objects
git fetch	                Downloads specific objects
git branch -r	            Lists remote branches; 
                            can be combined with other branch arguments to manage remote branches

You can also see more in the video Cryptography in Action from the course IT Security: Defense against the digital dark arts.
"""
#%%
"""
3.2.6 Practice Quiz

Question 1
In order to get the contents of a remote branch without automatically merging, 
which of these commands should we use?

-git pull
-git remote update CORRECT
You got it! 
git remote update will fetch the contents of all remote branches and allow us to merge the contents ourselves.
-git checkout 
git checkout switches branches but will not download remote updates.
-git log -p -1

Question 2
If we need to find more information about a remote branch, which command will help us?

-git fetch 
git fetch will download remote updates, such as objects and refs, from the remote branch.
-git checkout
-git remote update
-git remote show origin CORRECT
Right on! 
If you want to see more information about a particular remote branch, 
you can use the git remote show command. Don't forget the commit ID!

Question 3
What command will download remote branches from remote repositories 
without merging the content with your current workspace automatically?

-git checkout
-git pull
-git fetch CORRECT
Nice work! 
git fetch will download remote updates, such as objects and refs, from the remote branch, without merging the content with your current workspace automatically
-git remote update 
Not quite. 
git remote update will fetch the contents of all remote branches, and allow us to merge the contents ourselves.

Question 4
What type of merge creates a new merge commit?

-Fast-forward merge 
Not quite. Fast-forward merges are a type of implicit merge, which do not create new commits
-Implicit merge
-Explicit merge CORRECT?
Woohoo! An explicit merge creates a new merge commit. 
This alters the commit history and explicitly shows where a merge was executed.
-Squash on merge

Question 5
What method of getting remote contents 
will automatically merge the remote branch with the current local branch?

-git fetch
-git checkout
-git remote update
-git pull CORRECT
Great job! git pull automatically merges the remote branch with the current branch.
"""
#%%
"""
Introduction to Git and GitHub, by Google

WEEK 3 - Working with Remotes

3.3 Solving Conflicts
    3.3.1 The Pull-Merge-Push Workflow
    3.3.2 Pushing Remote Branches
    3.3.3 Rebasing Your Changes
    3.3.4 Another Rebasing Example
    3.3.5 Best Practices for Collaboration
    3.3.6 Conflict Resolution Cheat Sheet
    3.3.7 Practice Quiz

MY SYNOPSIS
when working with a remote repository on GitHub and its clone/copy local repository on my machine:
    first pull then push
    pull changes from the remote (fetch changes and merge them to my local repository)
    Git will try to do all possible automatic merges and only leave manual conflicts for us to resolve when the automatic merge fails.

MERGE CONFLICT MARKERS
when a merge happens Git alters our file and adds the following markers:
1   <<<<<<< HEAD
2   =======
3   >>>>>>>

explanation:
we have the branch "main" and the branch "new branch"
we try to merge the new branch to the main (and produce one branch, the updated main)
we cannot merge because there was a change.
In the file Git made some changes eventhough merge was not successful:
1   All the content between the center and the <<<<<<< HEAD line 
    is content that exists in the current branch master which the HEAD ref is pointing to
2   The ======= line is the "center" of the conflict
3   all content between the center and >>>>>>> new branch
    is content that is present in the new branch we want to merge into the main

EXPLANATION, see 2.3.5 script free_memory.py: 

INITIAL SCRIPT ON       SCRIPT ON BRANCH "MAIN"                                 SCRIPT ON BRANCH "NEW BRANCH"
LOCAL REPOSITORY
#!/usr/bin/env python3  #!/usr/bin/env python3                                  #!/usr/bin/env python3
def main():             def main():                                             def main():
    pass                    Checks if there is enough memory in the computer        print("Everything is OK.")
main()                  main()                                                  main()

-So, we had an identical script in both branches
-we modified the script while on the main branch
-we also modified the script while on the new branch
-then we tried to merge the new branch to the main,
but we failed because the change was different but exactly on the same part of the script
-we see the message:
    CONFLICT (content): Merge conflict in free_memory.py
    Automatic merge failed; fix conflicts and then commit the result.
- Git cannot merge automatically because it cannot choose which change to apply on the same part of the script
-So, we must intervene manually
-open editor to see the script, Git has changed it and added conflict markers!
 Git tells us what we did and where
 the altered script looks like this:
                    #!/usr/bin/env python3
                    def main():
                    <<<<<<< HEAD
                        "Checks if there is enough memory in the computer"
                    =======
                        print("Everything is OK.")
                    >>>>>>> even-better-feature
                    main()
                    
                    #!/usr/bin/env python3
                    def main():                
                        "Checks if there is enough memory in the computer"                 
                        print("Everything is OK.")
                    main()




COMMAND "git log -p <branch>": shows commit history for a certain branch
                               e.g git log -p origin/master shows commit history 
                               for the branch "master" of the remote repository
                               
PUSH A BRANCH FROM LOCAL TO MAIN BRANCH ON REMOTE, FOR THE FIRST TIME!
the first time we push a branch to the remote repository, we add a few more parameters to the command "git push"
this is not merging, we add a branch of our local to the main branch of the remote for revision by others
COMMAND "git push -u <remote branch> <new local branch>": -u is up-stream
                                                          remote branch to which we are pushing
                                                          local branch being pushed
COMMAND "git push -u origin refactor": # add the -u flag to create the branch up-stream 
                                        (which is another way of referring to remote repositories)
                                       # add origin, to push this to the remote repository 
                                        ("origin" is used to specify the remote repository)
                                       # add name of the branch we are pushing 
                                        (name of the branch we are "sending" to the remote repository)

GIT MERGE AND GIT REBASE (see also word file with pictures)

git merge and git rebase do the same thing: they merge a new branch into the main branch
BUT they do this differently: git merge preserves commit history while git rebase re-writes it as a linear commit history

Initially, Git searches for 3 commits:
(1):    the common ancestor commit
        at this point in time, both branches had the same content (and then evolved differently)
(2):    latest commit on one branch
(3):    latest commit on the other branch

git merge
"git merge <branch b>": merges the new branch b into the main branch b
    fast-forward merge, when main branch a does not have new commits since the branching happened
                        and new branch b has two new commits since the branching happened
                        finally we have branch ab, commit history: C1, C2, C3
                        C1 common ancestor commit
                        C2, C3 commits of branch b
    three-way merge     when main branch a has one commit since the branching happened
                        and new branch b has two new commits since the branching happened
                        finally we have branch ab, commit history: C1, C2, C3, C4, C5
                        C1 common ancestor commit
                        C2, C3 commits of branch b
                        C4 commit of branch a
                        C5 is the MERGE COMMIT

git rebase
git rebase does the merge in THREE STEPS
when main branch a has one commit C3 since the branching happened
and new branch b has two new commits C2, C4 since the branching happened

git checkout <branch b>: switch into branch b
git rebase <branch a>  : change the base of branch a
                         substitute base of branch a with base of branch b
                         base  = history of commits
                         STEP 1, remove C3 commit of branch a
git checkout <branch a>: switch into branch a
                         apply the commits from branch b that we want to integrate 
                         add base of branch b
                         we have temporary branch ab, commit history: C1, C2, C4
                         C1 common ancestor commit
                         C2, C4 commits of branch b
                         STEP 2, add commits of branch b
git merge <branch b>:   merge changes of branch b to branch a
                        add base of branch a on top of the base of branch b
                        commit C3 of branch a is now re-applied BUT ON TOP of the commits from branch b
                        we have final branch ab, commit history: C1, C2, C4, C3
                        C1 common ancestor commit
                        C2, C4 commits of branch b
                        C3 commit of branch a
                        STEP 3, add commits of branch a on top of commits of branch b

switch into branch b
remove the base of branch a
paste the base of branch b (use base of branch b as a base for branch a), temporary branch ab is produced
on the temporary branch ab, paste again the base of branch a after the base of branch b
"""
#%%
"""
3.3.1 The Pull-Merge-Push Workflow

I have the remote repository health_checks
I cloned/copied it to my machine as a local repository

I apply changes to the local
when trying to push them to the remote I get an error because
someone else also made changes to the remote
So, first pull, manage any merge conflicts and then push

(Git will try to do all possible automatic merges and 
only leave manual conflicts for us to resolve when the automatic merge fails.)

merge conflict marker = >>>

EXAMPLE 
cd health-checks # I am on my local
nano all_checks.py # open editor, apply changes to this file 
CTRL O, ENTER, CTRL X # save changes
git add -p            # review changes before adding them to the staging area
git commit -m 'renamed a function'
                      # commits the change to my local repository
                      and also adds a commit message
git push              # pushes changes to the remote repository (updates the remote with the changes we did on our local)
                      # we see that git push FAILED
                      WHY? because "the remote contains work that you do not have locally.
                      'first integrate remote changes before pushing again'
                      
git pull              # updates local repository for changes made to the remote repository  
                      # I see the message: 'Merge conflict in all_checks.py
                      fix conflicts and then commit the result'
                      So, there is a merge conflict that Git cannot resolve by itself,
                      maybe it is done on the same part of the file "all_checks.py" and Git does not know which change to apply (change in the remote or change in the local?)
                      Other merges were done without this message
                      Only the change happening at the same line in the file, produced this conflict and needs our input
git log --graph --oneline --all
                      # display all commits
                        --graph for displaying commits as a graph
                        --oneline for displaying one line per commit   
                        --all for 
                        we see all commits in all branches (the main and the other branches)
                        main branch (our local repository)
                        origin/main branch (the remote)
                        the branch 'origin/experimental' (on the remote repository) 
                        we will do a three-way merge

git log -p origin/master # 
                          git log -p shows associated patches, text is longer
                          we choose to see commits on the branch "origin/master", the main branch of the remote repository
                          remember, I am investigating the merge conflict
                          exit with q
nano all_checks.py  # open editor, display the script in this file
                     I see the conflict marker >>>>>>>                   
                    So, I open this on my local and see the conflict markers on the py file?
                    WE FIX THE CONFLICT HERE (keep the change I want), after that I will do: git add and git commit to finish the merge
                    If we want to search for other conflicts search for >>>
CTRL O, ENTER, CTRL X
git add all_checks.py   # add the modified file to the staging area
git commit              # commit the file to the local repository
                        # this command opens the editor
                        I see the health-check/.git/COMMIT_EDITMSG
                        so I see the commit message
                        it tells me that this is a MERGE:)
                        'it looks like you may be commiting a merge.'
                        The editor message shows that it is performing a merge of the remote branch with the local branch
                        We can add extra information to this message
                        The merge is ready, we can push this merge to the remote again
git push                # pushes changes to the remote repository (updates the remote with the changes we did on our local)
                        # now this push is successful
                        
git log --graph --oneline # we see all commits in all branches (the main and the other branches)                     
                           the latest commit is the merge

when Git needs to do a three-way merge, 
we end up with a separate commit for merging the branches back into the main tree.

"""
#%%
"""
3.3.2 Pushing Remote Branches

LOGIC: I have remote on GitHub, local on my machine
There is the origin/main branch on the remote
There is the main branch on my local
I create another branch on my local called "refactor"
I push the branch "refactor" on the remote for others to see, to test and tell me if they like it.
So I am adding a new branch to the origin/main branch on the remote with a special git push command
See next section on what to do 1) if the collaborators like the new branch 2) if they do not like it


I have the remote repository health_checks
I cloned/copied it to my machine as a local repository

I have the main branch on my local repository
then I can create other branches to do my tests again on my local repository

code refactoring =  is the process of restructuring existing computer code

EXAMPLE
cd health-checks
git checkout -b refactor  # creates a new branch and switches into it
                            I created a new branch called "refactor"
                            I switched to this branch
nano all_checks           # open the nano editor, I am making changes to this file
CTRL O, ENTER, CTRL X     # save the changes
./all_checks              # run the file, it works
git commit -a -m 'I corrected a function'
                          # stage and commit in one step
                          so, this happens on my local repository, on the branch "refactor"
nano all_checks           # do additional changes                           
CTRL O, ENTER, CTRL X     # save the changes
./all_checks              # run the file,it still works
git commit -a -m 'add an iteration'
                          # stage and commit in one step
nano all_checks           # open the nano editor, I am making changes to this file
CTRL O, ENTER, CTRL X     # save the changes
./all_checks              # run the file,it works
git commit -a -m 'print more errors'
                          # stage and commit in one step

so, we have 3 commits in the branch "refactor"
before merging the branch "refactor" to the main branch,
we will push this to the remote so our collaborators can view it, test it and tell us if it is ready for merging

the first time we push a branch to the remote repository,
we add a few more parameters to the command "git push"

git push -u origin refactor # add the -u flag to create the branch up-stream ( which is another way of referring to remote repositories)
                            # add origin, to push this to the remote repository ("origin" is used to specify the remote repository)
                            # add name of the branch we are pushing (name of the branch we are "sending" to the remote repository)
I get the message "create a pull request for 'refactor' on GitHub by visiting: ...
The branch "refactor" has been created in the remote repository!! It is a new branch for the remote repository

Now that our branch "refactor" is pushed to the remote repository,
it can be reviewed by our collaborators
                        
"""
#%%
"""
3.3.3 Rebasing Your Changes

please see previous section 3.3.2
Our collaborators APPROVE the new branch "refactor" that we created on our local and we pushed to the remote,
SO 
now we will merge this new branch into the origin/main branch of the remote repository

See theory for merging on Week 2

we can merge two branches with:
1) git merge <branch>: merges one branch into another, creates a new commit called Merge Commit                      
                       (Remember: when I want to merge a new branch into the main branch,
                       first I have to switch to the main branch and THEN do the merge)
                       
2) git rebase <branch>: merges a new branch to the main branch, re-arranges sequence of commits
                        after the merge, on the updated main branch we see,
                        first the commits of the new branch then the commits of the main branch 
                        (we disrupted the chronological order).
                        git rebase re-writes the commit history to produce a straight, linear succession of commits.
git rebase <branchname>: to change the base of the current branch to be branchname                       
Rebasing means changing the base commit that's used for our branch.

Difference between git merge and git rebase: 
git merge creates a new merge commit
git rebase re-writes sequence of commits

The golden rule of git rebase is to never use it on public branches.

In-Video Question
what does the git rebase refactor do?
It moves the current branch on top of the refactor branch

My notes for git rebase
git rebase main         step 1 "cut" commit history of branch main
git checkout refactor   step 2 "copy" commit history of branch refactor
git merge refactor      step 3 "paste" commit history of branch refactor, then commit history of branch "main" into the branch "main"

EXAMPLE

git checkout main      # we switch into the main branch on our local
                       switched to branch 'main'
                       Your branch is up to date with 'origin/main'
git pull              # updates local repository for changes made to the remote repository                       
                        Git tells us it updated our local main branch with changes that a colleague made on the origin/main branch on the remote repository
at this point, the changes that we have in the branch "refactor" can no longer be merged 
through fast forwarding into the main branch. 
That's because there's now an extra commit in the master that's not present in the refactor.                      
Lets see how this looks like with git log --graph --oneline --all

git log --graph --oneline --all
                       # displays commits on all branches in local and remote
                       we see a complex history tree
To make history of commits LINEAR we will use git rebase

git checkout refactor # we switch into the branch "refactor"
                       Switched to branch 'refactor'
                       Your branch is up to date with 'origin/refactor'
                       
git rebase main      # rebases commit history of branch "main" STEP 1
                     First, rewinding head to replay your work on top of it...
git log --graph --oneline --all
                     # displays commits on all branches in local and remote
                     now we can see the main branch and linear history of the commits
git checkout main    # switch to branch " main" STEP 2

git merge refactor   # merge changes of branch refactor" into the branch "main"
                      the commits on branch main are now reapplied - but on a new position, 
                      on top of the integrated commits from branch refactor
                      (the commits on branch main are re-based).
we were able to merge our branch through a fast forward merge and keep our history linear.

Now that we have merged the branch refactor into the brach main,
we can get rid of it both remotely and locally

git push --delete origin refactor
                     # delete a branch in a remote repository
                     # removes the remote branch
                     
git branch -d refactor # delete a branch in my local repository
                       # removes the local branch

git push             # apply changes done to our local TO the remote repository

WE USED GIT REBASE TO INTEGRATE A NEW BRANCH TO THE MAIN BRANCH, BY KEEPING A LINEAR HISTORY OF COMMITS
"""
#%%
"""
3.3.4 Another Rebasing Example

In 3.3.3, we used git rebase in order to 
merge/integrate a new branch into the main branch by keeping commit history linear.

Here, we will merge our changes to the main branch WITH the changes of another person on the main branch,
by also keeping the commit history linear

EXAMPLE
remote repository on GitHub: health-checks
cloned local repository on my machine: health-checks
both repositories are updated, no difference between them

nano all_checks.py # open this and make changes
CTRL O, ENTER, CTRL X # save changes
git commit -a -m 'Added a function' # this adds and commits in one step
                                    we commited a change in our local
git fetch          # fetches changes from the remote repository BUT DOES NOT merge them to our local repository             
                   # we want to update our local with the changes from the remote
                     but we will not use git pull to do  git fetch + git merge  
                   IN THIS CASE WE WANT TO KEEP COMMIT HISTORY LINEAR, SO WE'LL USE GIT REBASE BELOW!                                 
                   Indeed there are changes to the remote
git rebase origin/main # rebases commit history of branch "origin/main" STEP 1  "cut" commit history                 
                       WE HAVE A CONFLICT, WE NEED TO FIX IT
nano all_checks.py # open this and remove conflicts manually
./all_checks.py    # run this , it works
git add all_checks.py # add it to the staging area on my local

git rebase --continue # NOW CONTINUE WITH THE REBASE
                       rebase has finished successfully

git log --graph --oneline # see commit history
                          we see we've applied our change on top of the other changes without needing a three-way merge

git push              # apply changes to our local TO the remote

WE KEPT COMMIT HISTORY LINEAR
"""
#%%
"""
3.3.5 Best Practices for Collaboration

1) always synchronize your branches before starting any work on your own.
2) avoid having very large changes that modify a lot of different things
make many small changes and commit them 
3) when working on a big change, it makes sense to have a separate feature branch.
4) regularly merge changes made on the master branch back onto the feature branch.                      
5) have the latest version of the project in the master branch and 
   a stable version of the project on a separate branch.
6) do not rebase changes that have been pushed to remote repositories
7) write good commit messages
                           
"""
#%%
"""
3.3.6 Conflict Resolution Cheat Sheet

Merge conflicts are not uncommon when working in a team of developers, or on Open Source Software. Fortunately, GitHub has some good documentation on how to handle them when they happen:

https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-merge-conflicts
https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/resolving-a-merge-conflict-using-the-command-line
You can also use git rebase <branchname>: to change the base of the current branch to be branchname

The git rebase command is a lot more powerful.  Check out this link for more information.
"""
#%%
"""
3.3.7 Practice Quiz

1.
Question 1
If you’re making changes to a local branch 
while another user has also made changes to the remote branch, 
which command will trigger a merge?

git push
git pull CORRECT
git rebase
git fetch

Nice job! The git pull command runs git fetch with the given parameters, then calls git merge to merge the retrieved branch heads into the current branch.
2.
Question 2
Which of the following is a reason to use rebase instead of merging?

When you want to keep a linear commit history CORRECT
When you want a set of commits to be clearly grouped together in history
When you are on a public branch
When pushing commits to a remote branch

Way to go! git rebase is useful for maintaining a clean, linear commit history.
3.
Question 3
Where should we keep the latest stable version of the project?

The master branch
A separate branch from the master branch CORRECT
The debug branch
A remote branch

Great work! It's common practice to keep the latest version in the master branch and the latest stable version in a separate branch.
4.
Question 4
Which of the following statements represent best practices for collaboration? (check all that apply)

When working on a big change, it makes sense to have a separate feature branch.
You should always rebase changes that have been pushed to remote repos.
Always synchronize your branches before starting any work on your own. CORRECT
Avoid having very large changes that modify a lot of different things. CORRECT

Awesome! That way, whenever you start changing code, you know that you're starting from the most recent version, and you minimize the chances of conflicts or the need for rebasing.
Woohoo! Instead, try to make changes as small as possible, as long as they’re self-contained.
5.
Question 5
What command would we use to change the base of the current branch?

git checkout <branchname>
git pull
git rebase <branchname> CORRECT
git fetch

Right on! You can also use git rebase <branchname> to change the base of the current branch to be <branchname>.
"""
#%%
"""
Introduction to Git and GitHub, by Google

WEEK 3 - Working with Remotes

3.4 Qwiklabs Assessment: Introduction to Github

Contents
1   CREATE A REMOTE REPOSITORY ON GIT HUB
2   CLONE THE REMOTE REPOSITORY ON MY MACHINE
3   CONFIGURE THE REPOSITORY add username and user email
4   EDIT THE README FILE ON MY LOCAL REPOSITORY AND PUSH IT TO THE REMOTE
5   CREATE A NEW FILE ON MY LOCAL REPOSITORY
6   ON GITHUB, ON THE REMOTE REPOSITORY CREATE AN EMPTY FILE
7   PUSH FILE OF STEP 5, FROM LOCAL TO REMOTE

#%%
1   CREATE A REMOTE REPOSITORY ON GIT HUB
name = directory1
description = qwiklabs week 3
private
initialize the repository with a readme

#%%
2   CLONE THE REMOTE REPOSITORY ON MY MACHINE
copy url of remote on github
go to linux command line (remote machine of the exercise)

git clone URL # copy remote repository, create the local

cd directory1 # navigate to the newly created local repository
ls            # display contents of local
README.md

 
3   CONFIGURE THE REPOSITORY add username and user email

git config --global user.name "Name"
git config --global user.email "user@example.com"

#%%
4   EDIT THE README FILE ON MY LOCAL REPOSITORY AND PUSH IT TO THE REMOTE

nano README.md # open file and add the text
    I am editing the README file. Adding some more details about the project description.
Ctrl-o, Enter key, and Ctrl-x # save file
git status
    The git status command shows the different states of files in your working directory and staging area, 
    like files that are modified but unstaged and files that are staged but not yet committed.
    You can now see that the README.md file shows that it's been modified.
On branch main
Your branch is up-to-date with 'origin/main'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   README.md RED!

no changes added to commit (use "git add" and/or "git commit -a")



git add README.md # add the file to the staging area
    Use the git add command to add content from the working directory into the staging area for the next commit. 
    When the git commit command is run, it looks at this staging area. 
    So you can use git add to craft what you'd like your next commit snapshot to look like. 
    To check the files in staging area use git status.
git status
On branch main
Your branch is up-to-date with 'origin/main'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   README.md RED

no changes added to commit (use "git add" and/or "git commit -a")
student-04-283ce6f0edc7@linux-instance:~/directory1$ ^C
student-04-283ce6f0edc7@linux-instance:~/directory1$ git add README.md
student-04-283ce6f0edc7@linux-instance:~/directory1$ git status
On branch main
Your branch is up-to-date with 'origin/main'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   README.md GREEN




git commit # A Git commit is like "saving" your work.
    This now opens an editor that asks you to type a commit message. 
    Every commit has an associated commit message. 
    A commit message is a log message from the user describing the changes.
    Enter the commit message of your choice or you can use the following text:
        I am editing the README file.

I am editing the README file.
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch main
# Your branch is up-to-date with 'origin/main'.
#
# Changes to be committed:
#       modified:   README.md
#



Ctrl-o, Enter key, and Ctrl-x # save file with the commit message

git push origin main
    Now, push the committed changes from your local repository to a remote repository on the main branch by using:
Username for 'https://github.com': FoteiniRodi
Password for 'https://FoteiniRodi@github.com':
Counting objects: 3, done.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 363 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/FoteiniRodi/directory1.git
   4b04a35..4a906d3  main -> main

        
        
You can check the changes made to the local README.md file on the remote repository on Github. 
You can see the last time when the README.md file was added/updated.
You can also see the commit ID just above the list of files in the repository.
 Click on the Commit ID to get more details related to the commit.

#%%
5   CREATE A NEW FILE ON MY LOCAL REPOSITORY

nano example.py

#!/usr/bin/env python 3
def git_operation():
 print("I am adding example.py file to the remote repository.")
git_opeation()

Ctrl-o, Enter key, and Ctrl-x
git add example.py
git commit # Enter a commit message
Ctrl-o, Enter key, and Ctrl-x

We will push these changes later in the lab.

#%%
6   ON GITHUB, ON THE REMOTE REPOSITORY CREATE AN EMPTY FILE

add file
create new file
name = empty_file
commit new file

#%%
7   PUSH FILE OF STEP 5, FROM LOCAL TO REMOTE

git push origin main # it fails

To https://github.com/FoteiniRodi/directory1.git
 ! [rejected]        main -> main (fetch first)
error: failed to push some refs to 'https://github.com/FoteiniRodi/directory1.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.


git pull origin main
    This opens an editor that asks you to enter a commit message for the merge operation 
    (remote repository to local repository).
    You can simply accept the default message or type your own message.
Ctrl-o, Enter key, and Ctrl-x

git push origin main # it succeeds

Counting objects: 5, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 773 bytes | 0 bytes/s, done.
Total 5 (delta 0), reused 0 (delta 0)
To https://github.com/FoteiniRodi/directory1.git
   c561a02..5e1b273  main -> main

git log

commit 5e1b273ade946d31cbac268f310c65067c3150d1
Merge: d815596 c561a02
Author: foteinirodis@gmail.com <FoteiniRodi>
Date:   Sun Nov 29 07:27:56 2020 +0000

    Merge branch 'main' of https://github.com/FoteiniRodi/directory1 into main
    I pulled updates from remote to my local

commit c561a02d9bb9ff74c8f28a09002876b0fb152b49
Author: FoteiniRodi <60667452+FoteiniRodi@users.noreply.github.com>
Date:   Sun Nov 29 09:26:46 2020 +0200

    Create empty_file

commit d8155964776a9a27a4b9dde3e095507f1e975901
Author: foteinirodis@gmail.com <FoteiniRodi>
Date:   Sun Nov 29 07:25:22 2020 +0000

    created the file add example.py on my local

commit 4a906d39f112e6aebddbf061bff7883eb1c4771d
Author: foteinirodis@gmail.com <FoteiniRodi>
Date:   Sun Nov 29 07:19:37 2020 +0000

    I am editing the README file.

commit 4b04a3536474ae1f810b062785d5a4be2633af6b
Author: FoteiniRodi <60667452+FoteiniRodi@users.noreply.github.com>
Date:   Sun Nov 29 09:11:46 2020 +0200




Introduction to Git and GitHub, by Google

WEEK 4 - Collaboration

4.1 Pull Requests
    4.1.1 Intro to Module 4: Collaboration
    4.1.2 A Simple Pull Request on GitHub
    4.1.3 The Typical Pull Request Workflow on GitHub
    4.1.4 Updating an Existing Pull Request
    4.1.5 Squashing Changes
    4.1.6 Git Fork and Pull Request Cheat Sheet
    4.1.7 Practice Quiz

MY SYNOPSIS
Pull request: ask the owner of a repository to add our changes to the working tree of the repository

Pull request using only  GitHub
create a pull request directly on github to ask the owner for very small changes
this creates a forked repository which sits on our account
Once you have forked a repo, you own your forked copy. 
This means that you can edit the contents of your forked repository without impacting the parent repo

Fork a repository: copy a repository on github to work on it

Pull request using local and forked
large requests
fork someone else's repository (same repository but it sits on my account on GitHub) 
now I have the forked directory on my GitHub account
clone the forked directory
now I have a local repository on my machine.
Eventually, I will work with my local repository and the forked repository as the remote.
I do changes on the local, push them to my forked 
Then I will do a Pull Request on the original repository on github

git checkout -b add-readme   # to create the file first we create the branch
                             switched to a new branch called "add-readme"
git push -u origin add-readme # push the change to the remote indicated by 'origin' for the first time
                                and write name of file too
                                git push -u origin <filename>
                                we push this my github account, to the forked repository!

Update a Pull request
do a change on our local
push it to our forked on github
then update our pull request to the original

git push                 # push this change to the remote
                         notice it is the second time we do a push
                         so I do not need to use additional info for the git push command

Squash 2 commits in 1, to do a Pull request
git rebase -i main  # squash 2 changes in one commit
pick keyword in editor, pick takes the commits, and rebases them against the branch we selected
we have two options for combining commits
1 squash
2 fix up
Squash combines the commit messages into one. Fixup discards the new commit message

replace pick keyword with squash keyword to squash/incorporate/merge the commit to the previous one

git log --graph --oneline --all --4
           # see last 4 commits

git push -f # force the push even when Git detects conflict, even resulting in permanent data loss.not recommended 

"""
#%%
"""
4.1.1 Intro to Module 4: Collaboration

 In this module, we'll keep exploring the collaboration tools available in Git.
 We'll learn about tools that allow us to send changes to projects that we aren't a member of, 
 help us improve the quality of our code, and let us track our work better. 
 Some of these tools will be specific to GitHub, but most of the Git repository hosting services have similar tools. 
 So the concepts will still apply if you decide to use a different platform. 
 In recent years, GitHub has become a super popular platform for collaboration across many projects. 
 It's used heavily for open-source projects.
 These are projects that allow anyone to use, copy, and modify their code. 
 Having the code published online means that anybody in the world can learn from what the project is doing, 
 and even collaborate on fixes and extra features. 
 It also helps us learn from each other, because we can look at how others have solved the problem that 
 we're tackling. 
"""
#%%
"""
 4.1.2 A Simple Pull Request on GitHub
 
Here we will learn how to:
create a pull request directly on GitHub by using the web interface to edit files.
 
 
go to github and create a remote repository called validations belonging to blue-kale
create the py file validations
#!/usr/bin/env python 3
def validate_user(username, minlen):
    """Checks if the recieved username matches the required conditions"""
    if type(username) != str:
        raise TypeError("username must be a string")
    if minlen < 1:
        raise valueError("minlen must be at least 1")
        
    if len(username) < minlen:
        return false
    if not username.isalnum():
        return False
    # usernames cannot begin with a number
    if username[0].isnumeric():
        return False
    return True

Another person, user RF (me) locates an error
I locate a typing error
I click EDIT
Git tells me we i am trying to edit a file, that I do not have access to
Git tells me it created a fork of this project for me, in which I can commit my changes to
if I submit changes to this file, it will create a new branch so that I can send a pull request

FORK/ FORKING
Creates a copy of the remote repository of blue-kale so that it belongs to user RF
User RF can push changes to the forked copy, even when she cannot push changes to the remote repository

A GitHub fork is a copy of a repository (repo) that sits in your account 
rather than the account from which you forked the data from. 
Once you have forked a repo, you own your forked copy. 
This means that you can edit the contents of your forked repository without impacting the parent repo

forking is different than cloning a remote repository++

Typical workflow
create a fork of the repository
then work on that local fork

a forked repository is just like a normal repository, except Github knows which repo it forked from

eventually we can merge our changes back to the remote repo by creating a pull request

PULL REQUEST
A pull request is a commit or series of commits that you send to the owner of the repository so that
 they incorporate it into their tree. 
This is common because only a few people have commit rights to a repository and at the same time,
anybody can suggest, patches, bug fixes or even new features
So with pull requests, unauthorized users can suggest changes and then 
the owners of the repository can evaluate then and then apply them

SO:
correct the typing mistake
propose change/create commit on the forked repository
git created a branch <Name-patch-1> for us
Git tells us that merge can be done, no conflict
allow change from mainteners. Tick this! This way the maintaner can do the change without asking us
submit pull request

on the remote repository, the owner blu-kale can see "Pull requests 1"
"""
#%%
"""
 4.1.3 The Typical Pull Request Workflow on GitHub
  
when we propose a small change for someone else's repository
then editing and creating a pull request on GitHub is OK

BUT
if we want to propose a larger change we will 
fork someone else's repository (same repository but it sits on my account on GitHub) 
now I have the forked directory on my GitHub account
clone the forked directory
now I have a local repository on my machine.
Eventually, I will work with my local repository and the forked repository as the remote.

remote repository: is the forked repository that sits on my account on GitHub
local repository: is the copied forked repository, on my machine


fork a repository: copy it, acquire copy on my github account
clone a repository: copy it, acquire copy on my machine 

EXAMPLE
blue-kale's repository on github: original repository 'rearrange'
fork this to my account: forked repository rearrange or remote repository rearrange
clone this to my machine: local repository rearrange

On my machine:

cd rearrange     # navigate 
ls -l            # display contents
git log          # display commit history

now we can make any changes we like (to the local repository ofcourse)
blue-kale's repository does not have a readme file
we will add it

git checkout -b add-readme   # to create the file first we create the branch
                             switched to a new branch called "add-readme"
nano readme.md              # opens editor
                            we write
                            rearrange
                            =========
                            
                            This module is used for rearranging names
CTRL O, ENTER, CTRL X
git add README.md
git commit -m 'Added a simple README.md file'

Now, to push this change from my local to the forked repository (the remote),
I have to create a corresponding branch

git push -u origin add-readme # push the change to the remote indicated by 'origin' for the first time
                                and write name of file too
                                git push -u origin <filename>
                                we push this my github account, to the forked repository!
then on github                               
we will do a "Pull request" on the original repository 
On the original repository we see that: 
our branch is ahead of the original repositories master branch by one commit, which is the commit we just made. We can start our pull requests by clicking on the Pull Request link.

select "open a pull request"
see if the merge will be successful
Git tells us : able to merge
If this wasn't the case, we'd need to rebase our change against the current branch of the original repo so that it could be merged.
In the text window of the Pull Request write the reason we are proposing a change to the owner of the original repository
In the text window I can explain my change
for the example I write:
"Adding a README file that was missing from the project

also before submitting see the diff at the bottom!                 

each Pull request has an identifier, so if the owner of the original repository asks us to improve our Pull request we can find it easily
"""
#%%
"""
4.1.4 Updating an Existing Pull Request

here, we will update our Pull Request by
doing a change on our local
push it to our forked on github
then update our pull request to the original

When we send a pull request, it's pretty common to receive some comments from the project maintainers asking for some improvements. 

maintaner writes us a comment for our above Pull Request
"This README is tto short. it would be nice to see an example"

so
nano readme.md            # we write
                            rearrange
                            =========
                            
                            This module is used for rearranging names
                            Turns "Lastname, Firstname" into "Firstname Lastname"
                            # Example
                            Calling 'rearrange_name("Turing, Alan")' will return '"Alan Turing"'
CTRL O, ENTER, CTRL X

git commit -a -m 'Added more info to the README'
                         # this stages and commits in one step

git push                 # push this change to the remote
                         notice it is the second time we do a push
                         so I do not need to use additional info for the git push command
                         now the change is on my forked repository on github

Then on github update the previous Pull Request   
I can see this commit under the same Pull Request                     
We just pushed our commit to the same branch as before and GitHub automatically added it to the pull request.
 If we wanted to create a separate pull request, we would need to create a new branch instead. 
+++
"""
#%%
"""
4.1.5 Squashing Changes

Here, we will squash our changes into a SINGLE COMMIT

above I made 1 change, did a commit, created a pull request
then I made another change, did another commit and updated the first pull request
now, the maintaner of the original repository asks us to create a single commit that includes both changes
we will use git rebase -i main to do that

git rebase -i main  # squash 2 changes in one commit
                     rebase commit history of my 2 commits with the base of the main branch (of the original repository)
                     text editor opens with a list of all selected commits
                     pick 736d754 Added a simple README.md file
                     pick 01231b0 Added more info to the README
                     pick takes the commits, and rebases them against the branch we selected
we have two options for combining commits
1 squash
2 fix up

In both cases, the contents of the selected commit are merged into the previous commit in the list.                     
The difference is what happens with the commit messages. 
When we choose squash, 
the commit messages are added together and an editor opens up to let us make any necessary changes. 
When we choose fix up, the commit message for that commit is discarded. 

here, we will use squash to combine the commits in one and also modify the commit description
So let's change the pick command in the second line to squash it into the first one, then we'll save and exit the editor as usual.
                     pick 736d754 Added a simple README.md file
                     squash 01231b0 Added more info to the README
new text appears on editor, I can improve it
CTRL O, ENTER, CTRL X   

I see the message:
Successfully rebased and updated refs/heads/add-readme                

git show  # I see only one commit

git status # git tells us that our local has 1 commit, which is the rebase we just did
            On branch add-readme
            Your branch and 'origin/add-readme' have diverged
            and have 1 and 2 different commits each, respectively
            (use git pull to merge the remote branch into yours)
            nothing to commit, working tree clean

git log --graph --oneline --all --4
           # see last 4 commits
           We can see that the two commits pushed to the origin/add-readme branch 
           show up in a different path than the commit that's currently in our local add-readme branch. 
           This is expected whenever we do a rebase because the old commits are in the remote repo 
           and we have a different commit in our local repo.
git push # push changes from my local to my forked on github
         # fails
         in this case we do not want to do a merge
         we want to replace 1 old commits with 1 new one
         to do this we will use git push -f to force the push as it is!!!

git push -f # force the push
            # succeeds
            
git log --graph --oneline --all --4
            # we see 1 commit on top of main
            previous divergence is gone
            
go to github and see contents of the Pull Request on the original repository


          
"""
#%%
"""
4.1.6 Git Fork and Pull Request Cheat Sheet

Check out the following link for more information:

https://help.github.com/en/articles/about-pull-request-merges
"""
#%%
"""
4.1.7 Practice Quiz

1.
Question 1
What is the difference between using squash and fixup when rebasing?

Squash deletes previous commits.
Squash combines the commit messages into one. Fixup discards the new commit message.CORRECT
Awesome! The fixup operation will keep the original message and discard the message from the fixup commit, 
while squash combines them.
Squash only works on Apple operating systems.
Fixup combines the commit messages into one. Squash discards the commit message.

2.
Question 2
What is a pull request?

The owner of the target repository requesting you to add your changes.
A request sent to the owner and collaborators of the target repository to pull your recent changes.CORRECT
Right on! You send a pull request to the owner of the repository 
in order for them to incorporate it into their tree.
A request to delete previous changes.
A request for a specific feature in the next version.

3.
Question 3
Under what circumstances is a new fork created?

When you want to experiment with changes without affecting the main repository.CORRECT
Nice work! For instance, when you want to propose changes to someone else's project, 
or base your own project off of theirs.
When you clone a remote repository to your local machine.
During a merge conflict.
When there are too many branches.

4.
Question 4
What combination of command and flags will force Git to push the current snapshot to the repo as it is,
possibly resulting in permanent data loss?

git push -f CORRECT
Awesome! git push with the -f flag forcibly 
replaces the old commits with the new one and forces Git to push the current snapshot to the repo as it is. 
This can be dangerous as it can lead to remote changes being permanently lost and is not recommended 
unless you're pushing fixes to your own fork (nobody else is using it) such as in the case 
after doing interactive rebasing to squash multiple commits into one as demonstrated.
git log --graph --oneline --all
git status
git rebase -i

5.
Question 5
When using interactive rebase, 
which option is the default, and takes the commits and rebases them against the branch we selected?

squash
edit
reword
pick CORRECT
Great job! The pick keyword takes the commits and rebases them against the branch we have chosen.
"""
#%%
"""
Introduction to Git and GitHub, by Google

WEEK 4 - Collaboration

4.2 Code Reviews
    4.2.1 What are code reviews?
    4.2.2 The Code Review Workflow
    4.2.3 How to Use Code Reviews in GitHub
    4.2.4 More Information on Code Reviews
    4.2.5 Practice Quiz
    
MY SYNOPSIS

"""
#%%
"""
4.2.1 What are code reviews?


Doing a code review means going through someone else's code, 
documentation or configuration and checking that it all makes sense and follows the expected patterns. 

high quality code
catch mistakes of others
learn from others
collaborate remotely
"""
#%%
"""
4.2.2 The Code Review Workflow

Now, we'll check out a typical code review using a reviewing tool

finish our work
send it to the reviewer
reviewer sends us back comments with what must be fixed
we correct our mistakes on the code and on our reply to the reviewer
mark the comments from the reviewer as resolved
we can ask the reviewer for more information on how to fix mistakes
once all comments from the reviewer are resolved, our changes are approved and we can merge them

Types of comments from reviewer
typing mistakes
major problems with our code
style of the code (see style guide for coding, eg PEP8 for Python)
always ask for a style guide for your code

Code Reviewing systems
e.g. a maintaner must approve your code before you submit it
e.g. if other contributors vote favorably with +1's, you can submit it without asking the maintainner
"""
#%%
"""
4.2.3 How to Use Code Reviews in GitHu

how does the code reviewing process work specifically on GitHub?

You might remember that git commit dash dash amend modifies commits. 
So it's not safe to do with commits that have been pushed to the repo. 
Using amend is pretty much the same as creating a new commit, and then using an interactive rebase to fix up a change

git commit --amend is equivalent to git rebase -i (interactive rebase)

+++
"""
#%%
"""
4.2.4 More Information on Code Reviews
Check out the following links for more information:

http://google.github.io/styleguide/
https://help.github.com/en/articles/about-pull-request-reviews
https://medium.com/osedea/the-perfect-code-review-process-845e6ba5c31
https://smartbear.com/learn/code-review/what-is-code-review/
"""
#%%
"""
4.2.5 Practice Quiz

1.
Question 1
When should we respond to comments from collaborators and reviewers?

When their comments address software-breaking bugs
No need, just resolve the concerns and be done with it
Always CORRECT
Excellent! It is good manners and proper conduct to respond, even when it's simply an acknowledgement.
Only when a code correction is necessary

2.
Question 2
What is a nit?

A trivial comment or suggestion CORRECT
Good work! In git jargon (and elsewhere in the tech world), a nit is a minor “nitpick” about a piece of code.
A couple lines of code
A repository that is no longer maintained
An orphaned branch

3.
Question 3
Select common code issues that might be addressed in a code review. (Check all that apply)

Using unclear namesCORRECT
Following PEP8 guidelines
Forgetting to handle a specific conditionCORRECT
Forgetting to add testsCORRECT

4.
Question 4
If we've pushed a new version since we've made a recent change, what might our comment be flagged as?

Accepted
Resolved
Outdated correct
Nice job! If we push a new version after making a change, old comments are marked with the "Outdated" flag.
Merged not CORRECT
Not quite. You can comment on a merged commit, but you can't flag comments as merged.
5.
Question 5
What are the goals of code review? (Check all that apply)

Make sure that the contents are easy to understand
Ensure consistent style
Build perfect code
Ensure we don't forget any important cases

"""
#%%
"""
Introduction to Git and GitHub, by Google
WEEK 4 - Collaboration

4.3 Managing Projects
    4.3.1 Managing Collaboration
    4.3.2 Tracking Issues
    4.3.3 Continuous Integration
    4.3.4 Additional Tools
    4.3.5 Practice Quiz
    
    
"""
#%%
"""
4.3.1 Managing Collaboration

refactor a part of code that others are not currently working on to avoid conflicts
document well your code, write informative comments

If you're a project maintainer, it's important that you are reply promptly to pull requests and don't let them stagnate
big response time = higher probbability for additional commits
understand completely any changes you accept

ISSUE TRACKER
When it comes to coordinating who does what and when, a common strategy for active software projects is to use an issue tracker.

communication between collaborators
mailing list
IRC channels
now
slack channels
telegram groups
"""
#%%
"""
4.3.2 Tracking Issues

we'll talk about two important tools that can help us collaborate better,
 tracking issues and continuous integration.

issue tracker, bug tracker
helps us coordinate work

An issue tracker tells us the tasks that need to be done, the state they're in and who's working on them
The system also let's us add comments to the issue, these comments can be super helpful. They can give us more details about the problem, explain a way to solve it, or detail how to test if it's been solved. Issue trackers aren't just useful for people actively working on projects. 
They also let users report bugs when they come across them, even if they don't know how to solve the problem. 

bug tracker e.g. Bugzilla for open source projects

GitHub has an issue tracker of its own
see Issues at the page of a repository
When writing in issues description, it's a good idea to include all the information that we have about the problem or missing feature and any ideas on how to solve it.
issues have identification numbers (like pull requests)
if we have a pull request ID=5, there will not be an issue with id = 5!

resolving a pull request can close an issue automatically,
just add e.g. Closes: #4 #4 will be automatically detected by Git
    
  when solving an issue, have it assigned to you  
Assigning issues to collaborators helps us track who is working on what. By assigning the bug to yourself, you can let others know that you're working on it, so they don't need to.     
"""
#%%
"""
4.3.3 Continuous Integration

Continuous Integration (CI) system,
will build and test our code every time there is a change!
This means that it will run whenever there's a new commit in the main branch of our code.
It will also run for any changes that come in through pull requests
In other words, if we have continuous integration configured for our project, we can automatically run our tests using the code in a pull request. This way, we can verify that the test will pass after the new changes get merged back into the tree and that means instead of hoping our collaborators will remember to properly test their code, we can rely on our automated testing system to do it for us. 
Once we have our code automatically built and tested, the next automation step is continuous deployment

Continuous Deployment (or Continuous Delivery), CD
Continuous deployment means the new code is deployed often. The goal is to avoid roll outs with a lot of changes between two versions of a project and instead do incremental updates with only a few changes at a time. This allows errors to be caught and fixed early. Typical configurations include deploying a new version whenever a commit is merged into the main tree or whenever a branch is tagged for release.

whole system is called CI/CD
e.g. Jenkings

GitHub does not offer such a system
Some repository hosting services like GitLab provide their own infrastructure for doing continuous integration. GitHub doesn't offer an integrated solution. Instead, the popular alternative is to use Travis which communicates with GitHub and can access the information from GitHub projects to know which integrations to run. 

When creating a CI/CD
Pipelines
Pipelines specify the steps that need to run to get the result you want.
Artifacts
files that are generated as part of the pipeline

attention
1 make sure the authorized entities for the test servers are not the same entities authorized to deploy on the production servers.
2 always have a plan to recover your access in case your pipeline gets compromised

"""
#%%
"""
4.3.4 Additional Tools
Additional Tools
Check out the following links for more information:

https://arp242.net/diy.html 
https://help.github.com/en/articles/closing-issues-using-keywords
https://help.github.com/en/articles/setting-guidelines-for-repository-contributors 
https://www.infoworld.com/article/3271126/what-is-cicd-continuous-integration-and-continuous-delivery-explained.html
https://stackify.com/what-is-cicd-whats-important-and-how-to-get-it-right/
https://docs.travis-ci.com/user/tutorial/
https://docs.travis-ci.com/user/build-stages/
"""
#%%
"""
4.3.5 Practice Quiz

1.
Question 1
How do we reference issues in our commits with automatic links?

By using one of the keywords followed by a hashtag and the issue number. CORRECT
ight on! Keywords such as closes or resolves followed by a hashtag and the issue number will tell Git to autolink to the issue with the provided ID number.
By using an asterisk (*) after the issue number.
By typing the issue number inside braces ({}).
By using a special keyword.

2.
Question 2
What is an artifact in terms of continuous integration/continuous delivery (CI/CD) pipelines?

An old and obsolete piece of code or library.
Any file generated as part of the CI/CD pipeline. CORRECT
Awesome! Artifacts can include compiled code, test results, logs, or any type of file generated as part of the pipeline.
An unintended minor glitch in a computer program
An automated series of tests that run each time there is a new commit or pull request.

3.
Question 3
Which of the following statements are good advice for project maintainers? (Check all that apply)

Coordinate solely via email
Reply promptly to pull-requests CORRECT
Woohoo!  The more time that passes until a pull-request gets reviewed, the more likely it is that there's a new commit that causes a conflict when you try to merge in the change.
Understand any changes you accept CORRECT
Nice job! Not only do we not know whether the original coder is going to be around to maintain those functions, we also want to avoid feature creep and unmanageable code
Use an issue tracker CORRECT

4.
Question 4
Which statement best represents what a Continuous Integration system will do?

Run tests automatically CORRECT
Nice job! A continuous integration system will build and test our code every time there's a change.
Update with incremental rollouts 
Assign issues and track who's doing what
Specify the steps that need to run to get the result you want

5.
Question 5
Which statement best represents what a Continuous Delivery (CD) system will do?

Run tests automatically
Update with incremental rollouts CORRECT
Right on! Continuous Delivery means new code is often deployed with the goal of avoiding rollouts with lots of changes between two versions.
Assign issues and track who's doing what
Specify the steps that need to run to get the result you want

"""
#%%
"""
Introduction to Git and GitHub, by Google

WEEK 4 - Collaboration

4.4 Qwiklabs Assessment: Pushing Local Commits to Github

student-03-0d05814a1900@linux-instance:~$ git clone https://github.com/[git-username]/it-cert-automation-practice.git
Cloning into 'it-cert-automation-practice'...
fatal: unable to access 'https://github.com/[git-username]/it-cert-automation-practice.git/': The requested URL returned error: 400
student-03-0d05814a1900@linux-instance:~$ git clone https://github.com/FoteiniRodi/it-cert-automation-practice.git
Cloning into 'it-cert-automation-practice'...
remote: Enumerating objects: 25, done.
remote: Total 25 (delta 0), reused 0 (delta 0), pack-reused 25
Unpacking objects: 100% (25/25), done.
student-03-0d05814a1900@linux-instance:~$ cd ~/it-cert-automation-practice
student-03-0d05814a1900@linux-instance:~/it-cert-automation-practice$ git remote -v
origin  https://github.com/FoteiniRodi/it-cert-automation-practice.git (fetch)
origin  https://github.com/FoteiniRodi/it-cert-automation-practice.git (push)
student-03-0d05814a1900@linux-instance:~/it-cert-automation-practice$ git remote add upstream https://github.com/[git-username]/it-cert-automation-practice.git
student-03-0d05814a1900@linux-instance:~/it-cert-automation-practice$ git remote -v
origin  https://github.com/FoteiniRodi/it-cert-automation-practice.git (fetch)
origin  https://github.com/FoteiniRodi/it-cert-automation-practice.git (push)
upstream        https://github.com/[git-username]/it-cert-automation-practice.git (fetch)
upstream        https://github.com/[git-username]/it-cert-automation-practice.git (push)
student-03-0d05814a1900@linux-instance:~/it-cert-automation-practice$


cat validations.py
#!/usr/bin/env python3

import re

def validate_user(username, minlen):
    """Checks if the received username matches the required conditions."""
    if type(username) != str:
        raise TypeError("username must be a string")
    if minlen < 1:
        raise ValueError("minlen must be at least 1")

    # Usernames can't be shorter than minlen
    if len(username) < minlen:
        return False
    # Usernames can only use letters, numbers, dots and underscores
    if not re.match('^[a-z0-9._]*$', username):
        return False
    # Usernames can't begin with a number
    if username[0].isnumeric():
        return False
    return True


"""




